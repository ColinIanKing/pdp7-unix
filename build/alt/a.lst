		"** 01-s1.pdf page 62
		" sop
		dac = 0040000			" MEM: deposit AC
	040000  
		jms = 0100000			" MEM: jump to subroutine
	100000  
		dzm = 0140000			" MEM: deposit zero to memory
	140000  
		lac = 0200000			" MEM: load AC
	200000  
		xor = 0240000			" MEM: XOR with AC
	240000  
		add = 0300000			" MEM: one's complement add
	300000  
		tad = 0340000			" MEM: two's complement add
	340000  
		xct = 0400000			" MEM: execute
	400000  
		isz = 0440000			" MEM: increment and skip if zero
	440000  
		and = 0500000			" MEM: AND
	500000  
		sad = 0540000			" MEM: skip if AC different
	540000  
		jmp = 0600000			" MEM: jump
	600000  
		nop = 0740000			" OPR: no-op
	740000  
		i = 020000			" indirect
	020000  
		law = 0760000			" OPR: load accumulator with (instr)
	760000  
		cma = 0740001			" OPR: complement AC
	740001  
		las = 0750004			" OPR: load AC from switches
	750004  
		ral = 0740010			" OPR: rotate AC left
	740010  
		rar = 0740020			" OPR: rotate AC right
	740020  
		hlt = 0740040			" OPR: halt
	740040  
		sma = 0740100			" OPR: skip on minus AC
	740100  
		sza = 0740200			" OPR: skip on zero AC
	740200  
		snl = 0740400			" OPR: skip on non-zero link
	740400  
		skp = 0741000			" OPR: skip unconditionally
	741000  
		spa = 0741100			" OPR: skip on positive AC
	741100  
		sna = 0741200			" OPR: skip on non-zero AC
	741200  
		szl = 0741400			" OPR: skip on zero link
	741400  
		rtl = 0742010			" OPR: rotate two left
	742010  
		rtr = 0742020			" OPR: rotate two right
	742020  
		cll = 0744000			" OPR: clear link
	744000  
		rcl = 0744010			" OPR: clear link, rotate left
	744010  
		rcr = 0744020			" OPR: clear link, rotate right
	744020  
		cla = 0750000			" OPR: clear AC
	750000  
		lrs = 0640500			" EAE: long right shift
	640500  
		lrss = 0660500			" EAE: long right shift, signed
	660500  
		lls = 0640600			" EAE: long left shift
	640600  
		llss = 0660600			" EAE: long left shift, signed
	660600  
		als = 0640700			" EAE: AC left shift
	640700  
		alss = 0660700			" EAE: AC left shift, signed
	660700  
		mul = 0653122			" EAE: multiply
	653122  
		idiv = 0653323			" EAE: integer divide
	653323  
		lacq = 0641002			" EAE: load AC with MQ
	641002  
		clq = 0650000			" EAE: clear MQ
	650000  
		omq = 0640002			" EAE: OR MQ into AC
	640002  
		cmq = 0650004			" EAE: complement MQ
	650004  
		lmq = 0652000			" EAE: load MQ from AC
	652000  
		dscs = 0707141			" DSK: clear status register
	707141  
		dslw = 0707124			" DSK: clear and load WC from AC
	707124  
		dslm = 0707142			" DSK: clear and load MAC from AC
	707142  
		dsld = 0707104			" DSK: clear and load TA and SA from AC
	707104  
		dsls = 0707144			" DSK: load status
	707144  
		dssf = 0707121			" DSK: skip on flags
	707121  
		dsrs = 0707132			" DSK: read status register
	707132  
		iof = 0700002			" PIC: interrupts off
	700002  
		ion = 0700042			" PIC: interrupts on
	700042  
		caf = 0703302			" CPU: clear all flags
	703302  
		clon = 0700044			" CLK: clear flag, enable
	700044  
		clsf = 0700001			" CLK: skip if overflow
	700001  
		"** 01-s1.pdf page 63
		clof = 0700004			" CLK: clear flag, disable
	700004  
		ksf = 0700301			" KBD: skip if flag set
	700301  
		krb = 0700312			" KBD: read buffer
	700312  
		tsf = 0700401			" TTY: skip if flag set
	700401  
		tcf = 0700402			" TTY: clear flag
	700402  
		tls = 0700406			" TTY: load buffer, select
	700406  
		sck = 0704301			" G-2: skip on console keyboard
	704301  
		cck = 0704304			" G-2: clear console keyboard
	704304  
		lck = 0704312			" G-2: load console keyboard
	704312  
		rsf = 0700101			" PTR: skip if flag set
	700101  
		rsa = 0700104			" PTR: select alphanumeric mode
	700104  
		rrb = 0700112			" PTR: clear flag, or read buffer
	700112  
		psf = 0700201			" PTP: skip if flag set
	700201  
		pcf = 0700202			" PTP: clear flag
	700202  
		psa = 0700204			" PTP: alphanumeric mode
	700204  
		cdf = 0700501			" G-2: clear display flags
	700501  
		lds = 0701052			" G-2: load display status
	701052  
		lda = 0701012			" G-2: load display address
	701012  
		wcga = 0704206			" G-2: ???
	704206  
		raef = 0700742			" G-2: resume after edges flag
	700742  
		rlpd = 0700723			" G-2: resume after light pen stop, disabled
	700723  
		beg = 0700547			" G-2: begin
	700547  
		spb = 0704401			" G-2: skip on push button flag
	704401  
		cpb = 0704404			" G-2: clear push button flag
	704404  
		lpb = 0704412			" G-2: load push buttons
	704412  
		wbl = 0704424			" G-2: write button lights
	704424  
		dprs = 0704752			" dataphone: read status
	704752  
		dpsf = 0704741			" dataphone: skip on flag
	704741  
		dpcf = 0704761			" dataphone: clear flag
	704761  
		dprc = 0704712			" dataphone: read character
	704712  
		crsf = 0706701			" CDR: skip if ready
	706701  
		crrb = 0706712			" CDR: read buffer
	706712  
		" S1
		.. = 0
	000000  
		t = 0
	000000  
		orig:
		   hlt				" overwritten with interrupt return addr
000000: 740040  
		   jmp pibreak			" dispatch to interrupt processing
000001: 603407  
		. = orig+7
	1000007  
		   -1				" only ever set (to -1): never read?!
000007: 777777  
		. = orig+020			" syscall (CAL) and user "interrupt" processing
	1000020  
		   1f				" addr for "CAL I": store return here on "CAL"
000020: 000032  
		   iof				" interrupts off
000021: 700002  
		   dac u.ac			" save user AC
000022: 045631  
		   lac 020			" save user return addr
000023: 200020  
		   dac 1f			" save as if "CAL I"
000024: 040032  
		   lac 1f-1
000025: 200031  
		   dac 020			" restore location 20
000026: 040020  
		   lac u.ac			" restore user AC
000027: 205631  
		   jmp 1f+1			" join "CAL I" processing
000030: 600033  
		   1f				" literal to restore location 20
000031: 000032  
		1: 0				" "CAL I" PC stored here
000032: 000000  
		   iof				" interrupts off
000033: 700002  
		   dac u.ac			" save user AC
000034: 045631  
		   lacq
000035: 641002  
		   dac u.mq			" save user MQ
000036: 045632  
		   lac 8
000037: 200010  
		   dac u.rq			" save user auto-index location 8
000040: 045633  
		   lac 9
000041: 200011  
		   dac u.rq+1			" save user auto-index location 9
000042: 045634  
		   jms copy; 10; u.rq+2; 6	" save user auto-index locations 10-15
000043: 101667  
000044: 000012  
000045: 005635  
000046: 000006  
		   lac 1b			" load user PC after system call
000047: 200032  
		   dac u.rq+8			" save user PC
000050: 045643  
		   -1				" load -1
000051: 777777  
		   dac .savblk			" set "save" flag (cleared by disk I/O?)
000052: 044072  
		   dac .insys			" set "in system" flag
000053: 044066  
		   lac uquant			" load user quantum count
000054: 205474  
		   jms betwen; d0; maxquant	" check if between 0 & maxquant??
000055: 101643  
000056: 004116  
000057: 004100  
		      jms swap			" no: swap processes
000060: 100136  
		   ion				" interrupts on
000061: 700042  
		   -1
000062: 777777  
		   tad u.rq+8			" get address of system call
000063: 345643  
		   jms laci			" load AC indirect??
000064: 101635  
		   jms betwen; o20001; swn	" range check
000065: 101643  
000066: 004161  
000067: 000256  
		      jmp badcal		" bad system call
000070: 601146  
		   tad swp			" add system call table base
000071: 340220  
		   dac .+1			" save as next instruction
000072: 040073  
		   jmp .. i			" dispatch system call
000073: 620000  
		. = orig+0100
	1000100  
		   jmp coldentry		" here to start kernel
000100: 604507  
		   jms halt
000101: 102254  
		okexit:
		   dzm u.ac			" 'OK' system call exit: clear user AC
000102: 145631  
		sysexit:			" common system call exit code
		   ion				" enable interrupts
000103: 700042  
		   lac .savblk			" load "save" flag
000104: 204072  
		   sza				" is zero (cleared by disk I/O)?
000105: 740200  
		   jmp 1f			" no: no disk I/O done?
000106: 600116  
		   jms copy; sysdata; dskbuf; 64 " copy system data to disk buffer
000107: 101667  
000110: 005542  
000111: 007700  
000112: 000100  
		   cla
000113: 750000  
		   jms dskio; 07000		" save to disk?
000114: 102162  
000115: 007000  
		1:
		   dzm .insys			" clear "in system call" flag
000116: 144066  
		   jms chkint			" pending user interrupt?
000117: 100320  
		      skp			"  no
000120: 741000  
		   jmp .save			"   yes: dump core
000121: 601151  
		   jms copy; u.rq+2; 10; 6	" restore auto-index locations 10-15
000122: 101667  
000123: 005635  
000124: 000012  
000125: 000006  
		   lac u.rq+1			" restore auto-index location 9
000126: 205634  
		   dac 9
000127: 040011  
		   lac u.rq			" restore auto-index location 8
000130: 205633  
		   dac 8
000131: 040010  
		   lac u.mq			" restore MQ register
000132: 205632  
		   lmq
000133: 652000  
		   lac u.ac			" restore AC register
000134: 205631  
		   jmp u.rq+8 i			" return to user
000135: 625643  
			" scheduler / idle loop
		swap: 0
000136: 000000  
		   ion
000137: 700042  
		1:
		   jms lookfor; 3 " out/ready
000140: 101066  
000141: 000003  
		      jmp 1f
000142: 600151  
		   jms lookfor; 1 " in/ready
000143: 101066  
000144: 000001  
		      skp
000145: 741000  
		   jmp 1b			" loop until a process becomes ready
000146: 600140  
		   dzm maxquant			" in/ready (self?): come back next tick!
000147: 144100  
		   jmp 3f
000150: 600215  
		1:				" here with out/ready process
		   dac 9f+t			" save process pointer (swapped out) in t0
000151: 044205  
		   jms lookfor; 2 " in/notready	" find a swapped in process to swap out?
000152: 101066  
000153: 000002  
		      jmp 1f
000154: 600161  
		   jms lookfor; 1 " in/ready
000155: 101066  
000156: 000001  
		      jmp 1f
000157: 600161  
		   jmp 2f
000160: 600177  
		1:
		   lac swap
000161: 200136  
		   dac u.swapret		" return to caller when swapped back
000162: 045650  
		   iof
000163: 700002  
		   lac o200000			" change status to swapped out
000164: 204170  
		   tad u.ulistp i
000165: 365647  
		   dac u.ulistp i
000166: 065647  
		   ion
000167: 700042  
		   jms dskswap; 07000		" swap process out
000170: 102267  
000171: 007000  
		   lac u.dspbuf
000172: 205712  
		   sna				" process using display??
000173: 741200  
		   jmp 2f			"  no
000174: 600177  
		   law dspbuf			" reset to default display buffer
000175: 764446  
		   jms movdsp
000176: 102615  
		2:
		   iof				" disable interrupts
000177: 700002  
		   lac o600000			" change status (1->7???]
000200: 204176  
		   tad 9f+t i
000201: 364205  
		   dac 9f+t i
000202: 064205  
		   ion				" enable interrupts
000203: 700042  
		   jms dskswap; 06000		" read process in?
000204: 102267  
000205: 006000  
		   lac u.swapret		" set our return addr
000206: 205650  
		   dac swap			" to saved return addr
000207: 040136  
		   lac o20			" reset maxquant to 16 ticks
000210: 204134  
		   dac maxquant
000211: 044100  
		   lac u.dspbuf
000212: 205712  
		   sza				" using display?
000213: 740200  
		"** 01-s1.pdf page 4
		   jms movdsp			"  yes. switch to user display bufferx
000214: 102615  
		3:
		   dzm uquant			" no. reset process tick count
000215: 145474  
		   iof
000216: 700002  
		   jmp swap i			" return
000217: 620136  
		t = t+1
	000001  
		swp:			" system call dispatch table
		   jmp .		" base instruction
000220: 600220  
		   .save; .getuid; .open; .read; .write; .creat; .seek; .tell
000221: 001151  
000222: 000426  
000223: 000626  
000224: 000724  
000225: 000773  
000226: 000660  
000227: 000431  
000230: 000461  
		   .close; .link; .unlink; .setuid; .rename; .exit; .time; .intrp
000231: 000720  
000232: 000467  
000233: 000542  
000234: 000561  
000235: 000567  
000236: 001163  
000237: 000610  
000240: 000257  
		   .chdir; .chmod; .chown; badcal; .sysloc; badcal; .capt; .rele
000241: 000615  
000242: 000407  
000243: 000421  
000244: 001146  
000245: 000262  
000246: 001146  
000247: 000377  
000250: 000403  
		   .status; badcal; .smes; .rmes; .fork
000251: 000352  
000252: 001146  
000253: 001225  
000254: 001177  
000255: 001111  
		swn:
		   .-swp-1 i		" count of system calls, plus indirect!
000256: 020035  
			" AC/ new value for intflg (non-zero to ignore interrupt char)
			"   sys intrp
		.intrp:
		   lac u.ac
000257: 205631  
		   dac u.intflg
000260: 045713  
		   jmp okexit
000261: 600102  
			" syscall to retrieve system addresses (data & routines!!)
			" AC/ index (1..17)
			"   sys sysloc
			" AC/ address (or -1 on bad index)
		.sysloc:
		   lac u.ac
000262: 205631  
		   and o17777
000263: 504160  
		   jms betwen; d1; locn
000264: 101643  
000265: 004117  
000266: 000317  
		      jms error
000267: 101531  
		   tad locsw
000270: 340275  
		   dac .+1
000271: 040272  
		   lac ..
000272: 200000  
		   dac u.ac
000273: 045631  
		   jmp sysexit
000274: 600103  
		locsw:			" table of system addresses for sysloc
		   lac .
000275: 200275  
		   iget; inode; userdata; sysdata; copy; copyz; betwen; dskrd
000276: 003017  
000277: 005732  
000300: 005631  
000301: 005542  
000302: 001667  
000303: 001712  
000304: 001643  
000305: 002116  
		   dskwr; dskbuf; dpdata; namei; pbsflgs; alloc; free; dspdata
000306: 002146  
000307: 007700  
000310: 005532  
000311: 002737  
000312: 005476  
000313: 001545  
000314: 001604  
000315: 005536  
		   crdata
000316: 005540  
		locn:
		   .-locsw-1
000317: 000021  
			" check if "interrupt" for current process
			" checks .int1 and .int2 (contain i-number of interrupt source)
			" compared against process stdin
			"
			" call:
			" .insys/ 0
			"   jms chkint
			"    no: no interrupt, or intflg set (discards interrupt)
			"   yes: PI off, .insys set
		chkint: 0
000320: 000000  
		   lac .insys
000321: 204066  
		   sza				" in system?
000322: 740200  
		   jmp chkint i			"  yes: return
000323: 620320  
		   lac .int1			" get inumber of interrupt1 source?
000324: 204067  
		   sna				" zero?
000325: 741200  
		   jmp 1f			"  yes: skip stdin check
000326: 600331  
		   sad u.ofiles+2		" non-zero: compare to stdin inumber
000327: 545656  
		   jmp 2f			"  same
000330: 600341  
		1:
		   lac .int2			" get inum of interrupt 2 source?
000331: 204070  
		   sna				" zero?
000332: 741200  
		   jmp chkint i			"  yes: return
000333: 620320  
		   sad u.ofiles+2		" non-zero: compare to stdin inumber
000334: 545656  
		   skp				"  match!
000335: 741000  
		   jmp chkint i			"   no match: return
000336: 620320  
		   dzm .int2			" clear int2 source
000337: 144070  
		   jmp 1f
000340: 600342  
		2:
		   dzm .int1			" clear int1 source
000341: 144067  
		1:
		"** 01-s1.pdf page 5
		   lac u.intflg			" get user intflg
000342: 205713  
		   sza				" zero?
000343: 740200  
		   jmp chkint i			"  no: ignore
000344: 620320  
		   -1
000345: 777777  
		   dac .insys			" set "in system" flag
000346: 044066  
		   ion				" enable interrupts
000347: 700042  
		   isz chkint			" give skip return
000350: 440320  
		   jmp chkint i
000351: 620320  
		"** 01-s1.pdf page 7
		" s2
			" file status (stat) system call
			" AC/ pointer to status (inode) buffer + i-num (13 words)
			"   sys status; dir_name_ptr; file_name_ptr
			"   NO_DD version: sys status; file_name_ptr
		.status:
		   jms arg			" fetch file name pointer
000352: 102625  
		   dac .+3
000353: 040356  
		   lac u.cdir			" get current working directory
000354: 205646  
		   jms namei; ..		" look up file
000355: 102737  
000356: 000000  
		      jms error			"  not found: return error
000357: 101531  
		   jms iget			" read file inode
000360: 103017  
		   lac u.ac			" get user buffer pointer
000361: 205631  
		   and o17777			" truncate to 13 bits
000362: 504160  
		   jms betwen; o10000; o17762	" is user memory (but not last 14 wds)?
000363: 101643  
000364: 004156  
000365: 004157  
		      jms error			"  no: error
000366: 101531  
		   dac .+3			" save as copy destination
000367: 040372  
		   jms copy; inode; ..; 12	" copy inode to user buffer
000370: 101667  
000371: 005732  
000372: 000000  
000373: 000014  
		   lac d.i			" copy i-num from last dnode read ??
000374: 205747  
		   dac 9 i			" save thru index 9 (pre-increment) ??
000375: 060011  
		   jmp okexit
000376: 600102  
			" capture display?
		.capt:
		   lac u.ac			" get user AC
000377: 205631  
		   dac u.dspbuf			" save as user display buffer
000400: 045712  
		   jms movdsp			" switch to user display buffer
000401: 102615  
		   jmp sysexit
000402: 600103  
			" release display?
		.rele:
		   dzm u.dspbuf			" clear user display buffer pointer
000403: 145712  
		   law dspbuf			" get default display buffer
000404: 764446  
		   jms movdsp			" change to it
000405: 102615  
		   jmp sysexit
000406: 600103  
		.chmod:
		   jms isown			" check if user owns file arg
000407: 102664  
		   lac u.ac			" get new permissions
000410: 205631  
		   and o17			" mask to read/write bits
000411: 504133  
		   lmq				" save in MQ
000412: 652000  
		   lac i.flags			" get file flags
000413: 205732  
		   and o777760			" clear permissions
000414: 504202  
		   omq				" or in new permissions from MQ
000415: 640002  
		   dac i.flags			" save in inode
000416: 045732  
		   jms iput			" write inode back
000417: 103046  
		   jmp okexit
000420: 600102  
		.chown:
		   jms isown			" check if user owns file arg
000421: 102664  
		   lac u.ac			" get new owner
000422: 205631  
		   dac i.uid			" save in inode
000423: 045742  
		   jms iput			" write inode back
000424: 103046  
		   jmp okexit
000425: 600102  
		.getuid:			" getuid system call
		   lac u.uid
000426: 205644  
		   dac u.ac			" return u.uid in user AC
000427: 045631  
		   jmp sysexit
000430: 600103  
		.seek:
		   jms seektell
000431: 102645  
		   tad u.base
000432: 345651  
		"** 01-s1.pdf page 8
		   spa
000433: 741100  
		   jms error
000434: 101531  
		   lmq
000435: 652000  
		   lac f.flags
000436: 205757  
		   and d1
000437: 504117  
		   sna
000440: 741200  
		   jms 1f
000441: 100450  
		   lacq
000442: 641002  
		   jms betwen; d0; i.size
000443: 101643  
000444: 004116  
000445: 005744  
		      jms dacisize
000446: 103402  
		   jmp 2f
000447: 600455  
		1:
		   lacq
000450: 641002  
		   jms betwen; d0; i.size
000451: 101643  
000452: 004116  
000453: 005744  
		      lac i.size
000454: 205744  
		2:
		   dac f.badd
000455: 045760  
		   dac u.ac
000456: 045631  
		   jms fput
000457: 102402  
		   jmp sysexit
000460: 600103  
		.tell:
		   jms seektell
000461: 102645  
		   cma
000462: 740001  
		   tad d1
000463: 344117  
		   tad u.base
000464: 345651  
		   dac u.ac
000465: 045631  
		   jmp sysexit
000466: 600103  
		.link:
		   jms arg			" Save the argument pointers in
000467: 102625  
		   dac 0f			"0f, 1f and 2f
000470: 040477  
		   jms arg
000471: 102625  
		   dac 1f
000472: 040502  
		   jms arg
000473: 102625  
		   dac 2f
000474: 040506  
		   lac u.cdir			" Search the current directory
000475: 205646  
		   jms namei; 0:0		" for the first argument
000476: 102737  
000477: 000000  
		      jms error			" Didn't find it
000500: 101531  
		   jms namei; 1:0		" In the i-num found by 1st namei,
000501: 102737  
000502: 000000  
		      jms error			" search for 2nd argument, err not found
000503: 101531  
		   dac u.base			" save in user data
000504: 045651  
		   jms copy; 2:0; name; 4
000505: 101667  
000506: 000000  
000507: 005504  
000510: 000004  
		   lac u.cdir			" Search the process' current directory
000511: 205646  
		   jms namei; name		" for the third argument
000512: 102737  
000513: 005504  
		      skp
000514: 741000  
		   jms error			" Error if it already exists
000515: 101531  
		   lac d1
000516: 204117  
		   dac mode			" Save mode bits for access
000517: 045500  
		   jms access			" check access (or return error to user)
000520: 102312  
		   jms dslot			" allocate directory slot
000521: 102463  
		   lac u.base			" get source file i-number
000522: 205651  
		   jms iget			" read inode in
000523: 103017  
		   lac ii			" get the i-num
000524: 205731  
		   dac d.i			" Save the i-num in the directory entry
000525: 045747  
		   jms copy; name; d.name; 4	" Copy the new link name into the directory entry
000526: 101667  
000527: 005504  
000530: 005750  
000531: 000004  
		   lac i.uniq			" Copy the i-node unique number into
000532: 205745  
		   dac d.uniq			" the directory entry
000533: 045754  
		   -1
000534: 777777  
		   tad i.nlks			" Decrement link count, i.e. one more link
000535: 345743  
		   dac i.nlks
000536: 045743  
		"** 01-s1.pdf page 9
		   jms iput			" Save the i-node and directory entry for
000537: 103046  
		   jms dput			" the new link
000540: 103136  
		   jmp okexit			" and return OK
000541: 600102  
		.unlink:
		   jms argname			" fetch filename, inode
000542: 102631  
		   dac u.base			" save i-number
000543: 045651  
		   lac d1			" write mode bit
000544: 204117  
		   dac mode			" save for access call
000545: 045500  
		   jms access			" check access or return error (reads inode)
000546: 102312  
		   dzm d.i			" clear directory i-num
000547: 145747  
		   jms dput			" write directory entry back
000550: 103136  
		   lac u.base			" get i-number back
000551: 205651  
		   jms iget			" read inode back
000552: 103017  
		   isz i.nlks			" increment link count (kept as negative count)
000553: 445743  
		   jmp 1f			"  not zero
000554: 600557  
		   jms itrunc			" zero links: free blocks
000555: 102675  
		   dzm i.flags			" clear status (free inode)
000556: 145732  
		1:
		   jms iput			" write inode back to disk
000557: 103046  
		   jmp sysexit
000560: 600103  
		.setuid:			" setuid system call
		   lac u.uid			" load current user id
000561: 205644  
		   sma				" negative (super user)
000562: 740100  
		   jms error			"  no: error!!
000563: 101531  
		   lac u.ac			" load user AC
000564: 205631  
		   dac u.uid			" save as new uid
000565: 045644  
		   jmp sysexit
000566: 600103  
			" rename system call:
			"   sys rename; old_name_ptr; new_name_ptr
			" Questions:
			"   when is directory entry read??
			"   is access check on directory or src file??
			"   check for existing file with new name??
			"   when is directory entry written back??
		.rename:
		   jms arg			" fetch first arg (old name pointer)
000567: 102625  
		   dac 0f			" save for namei
000570: 040575  
		   jms arg			" fetch second arg (new name pointer)
000571: 102625  
		   dac 1f			" save for copy
000572: 040603  
		   lac u.cdir			" get CWD
000573: 205646  
		   jms namei; 0:0		" search for (old) name
000574: 102737  
000575: 000000  
		      jms error			"  not found: return error
000576: 101531  
		   lac d1			" get write mode bit
000577: 204117  
		   dac mode			" save for access call
000600: 045500  
		   jms access			" access OK? (or return error to user)
000601: 102312  
		   jms copy; 1:0; d.name; 4	" copy new name into directory entry
000602: 101667  
000603: 000000  
000604: 005750  
000605: 000004  
		   jms dput			" and write it to disk
000606: 103136  
		   jmp okexit
000607: 600102  
			" time system call returns line (mains) frequency ticks
			" high order bits returned in AC, low order in MQ
			" s.tim is located in "system" block (written to disk)
			" so this is a running count of uptime since first boot!
			" at 60Hz, 36 bits would last 36+ years!
		.time:
		   lac s.tim			" load high order bits
000610: 205557  
		   dac u.ac			" return in AC
000611: 045631  
		   lac s.tim+1			" load low order bits
000612: 205560  
		   dac u.mq			" return in MQ
000613: 045632  
		   jmp sysexit
000614: 600103  
		.chdir:
		   jms argname			" fetch argument as filename
000615: 102631  
		   jms iget			" (re)read inode(?]
000616: 103017  
		   lac i.flags			" get flags
000617: 205732  
		   and o20			" get directory bit
000620: 504134  
		   sna				" is a directory?
000621: 741200  
		   jms error			"  no: return error to user
000622: 101531  
		   lac ii			" yes: get i-number
000623: 205731  
		   dac u.cdir			" save as current working directory
000624: 045646  
		"** 01-s1.pdf page 10
		   jmp okexit
000625: 600102  
			" open system call
			"   sys open; filename_ptr; flags (0 for read, 1 for write)
			" returns w/ "fd" in AC (or -1 if not found)
		.open:
		   jms arg			" get filename
000626: 102625  
		   dac 0f			" save for namei
000627: 040640  
		   jms arg			" get flags
000630: 102625  
		   sza				" zero (read)
000631: 740200  
		   lac d1			"  no: get write mode bit
000632: 204117  
		   sna				" non-zero (write)?
000633: 741200  
		   lac d2			"  no: get read mode bot
000634: 204120  
		   dac mode			" save for access call
000635: 045500  
		   lac u.cdir			" get current working directory
000636: 205646  
		   jms namei; 0:0		" search for file
000637: 102737  
000640: 000000  
		      jms error			" error: return -1
000641: 101531  
		   jms iget			" load inode
000642: 103017  
		   jms access			" check access (may return w/ error to user)
000643: 102312  
		   lac i.flags			" get file flags
000644: 205732  
		   and o20			" get directory bit
000645: 504134  
		   sna				" is directory?
000646: 741200  
		   jmp open1			"  no, join common code
000647: 600715  
		   lac mode			" get access mode
000650: 205500  
		   and d1			" get write bit
000651: 504117  
		   sna				" write access?
000652: 741200  
		   jmp open1			"  no, continue
000653: 600715  
		   lac u.uid			" yes: get uid?
000654: 205644  
		   sma				" negative? (-1 is superuser)
000655: 740100  
		   jms error			"  no: return error
000656: 101531  
		   jmp open1			" yes: join common code
000657: 600715  
		.creat:
		   lac d1			" mode bit 1 (write)
000660: 204117  
		   dac mode			" save for access call
000661: 045500  
		   jms arg			" get name pointer
000662: 102625  
		   dac .+2			" save for copy
000663: 040665  
		   jms copy; ..; name; 4	" copy filename to "name"
000664: 101667  
000665: 000000  
000666: 005504  
000667: 000004  
		   lac u.cdir
000670: 205646  
		   jms namei; name		" look up in current working directory
000671: 102737  
000672: 005504  
		      jmp 1f			"  not found
000673: 600711  
		   jms iget			" file exists: read inode
000674: 103017  
		   jms access			" check access (or return error to user)
000675: 102312  
		   lac i.flags			" get flags
000676: 205732  
		   and o20			" get directory bit
000677: 504134  
		   sna				" is a directory?
000700: 741200  
		   jmp .+4			"  no: skip to truncate
000701: 600705  
		   lac u.uid			" get user
000702: 205644  
		   sma				" is super user?
000703: 740100  
		   jms error			"  no: error
000704: 101531  
		   jms itrunc			" yes: truncate
000705: 102675  
		   cla
000706: 750000  
		   jms dacisize			" clear i.size
000707: 103402  
		   jmp open1
000710: 600715  
		1:
		   jms access			" here if not found
000711: 102312  
		   lac u.ac			" get access bits from user AC (zero for lock!)
000712: 205631  
		   and o17			" mask to permissions
000713: 504133  
		   jms icreat
000714: 102475  
		open1:				" common exit for open/creat
		   jms fassign			" assign fd slot
000715: 102327  
		      jms error			"  none free, return -1
000716: 101531  
		   jmp sysexit
000717: 600103  
		"** 01-s1.pdf page 11
		.close:
		   jms finac			" get fnode (open file) for fd in user AC
000720: 103370  
		   dzm f.flags			" clear flags
000721: 145757  
		   jms fput			" write fnode back to u.ofiles
000722: 102402  
		   jmp sysexit
000723: 600103  
		.read:
		   jms arg			" get argument
000724: 102625  
		   and o17777			" mask to address
000725: 504160  
		   dac u.base			" save as I/O base
000726: 045651  
		   jms arg			" get second argument
000727: 102625  
		   dac u.count			" save as count
000730: 045652  
		   lac u.base			" get base
000731: 205651  
		   jms betwen; o10000; o17777	" end inside user memory?
000732: 101643  
000733: 004156  
000734: 004160  
		      jms error			"  no: error
000735: 101531  
		   tad u.count			" get end of buffer
000736: 345652  
		   jms betwen; u.base; o17777	" inside buffer/user memory?
000737: 101643  
000740: 005651  
000741: 004160  
		      jms error			"  no: error
000742: 101531  
		   dac u.limit			" yes: save as I/O limit
000743: 045653  
		1:
		   jms finac			" get fnode for fd in user AC
000744: 103370  
		   lac f.flags			" get open file flags
000745: 205757  
		   and d1			" get write bit
000746: 504117  
		   sza				" open for write?
000747: 740200  
		   jms error			"  yes: error
000750: 101531  
		   lac i.flags			" get inode flags
000751: 205732  
		   and o40			" get special file bit
000752: 504136  
		   sna				" special?
000753: 741200  
		   jmp 1f			"  no
000754: 600762  
		   iof				" yes: disable interrupts
000755: 700002  
		   lac ii			" get i number
000756: 205731  
		   tad swr			" add to base instruction
000757: 341324  
		   dac .+1
000760: 040761  
		   jmp .. i			" dispatch to read routine
000761: 620000  
		1:
		   lac u.base			" get user base
000762: 205651  
		   dac 1f+1			" save as iread base
000763: 040770  
		   lac u.count			" get user count
000764: 205652  
		   dac 1f+2			" save as iread count
000765: 040771  
		   lac f.badd			" get file offset
000766: 205760  
		1:
		   jms iread; ..; ..
000767: 103266  
000770: 000000  
000771: 000000  
		   jmp exitrw
000772: 601034  
			" write system call:
			" AC/ fd
			"   sys write; buffer; count
			" AC/ count or -1 on error
		.write:
		   jms arg			" pick up buffer
000773: 102625  
		   and o17777			" mask to addr
000774: 504160  
		   dac u.base			" save as I/O base
000775: 045651  
		   jms arg			" pick up count
000776: 102625  
		   dac u.count			" save as count
000777: 045652  
		   tad u.base			" add base (get limit)
001000: 345651  
		   jms betwen; u.base; o17777	" check between base and end of memory
001001: 101643  
001002: 005651  
001003: 004160  
		      jms error			"  no: error
001004: 101531  
		   dac u.limit			" yes: save as limit
001005: 045653  
		   jms finac			" get fnode with fd from user AC
001006: 103370  
		   lac f.flags			" get open file table flags
001007: 205757  
		   and d1			" open for write?
001010: 504117  
		   sna				" if yes, skip
001011: 741200  
		   jms error			"   no: error
001012: 101531  
		   lac i.flags			" get inode flags
001013: 205732  
		   and o40			" get device bit
001014: 504136  
		"** 01-s1.pdf page 12
		   sna				" special?
001015: 741200  
		   jmp 1f			"  no
001016: 601024  
		   iof				" yes, special: turn interrupts off
001017: 700002  
		   lac ii			" get i number
001020: 205731  
		   tad sww			" get write routine entry addr
001021: 341324  
		   dac .+1
001022: 041023  
		   jmp .. i			" dispatch to write routine
001023: 620000  
		1:				" here with regular file
		   lac u.base			" get base
001024: 205651  
		   dac 1f+1			" save as iwrite arg 1
001025: 041032  
		   lac u.count			" get count
001026: 205652  
		   dac 1f+2			" save as iwrite 2
001027: 041033  
		   lac f.badd			" get fd offset
001030: 205760  
		1:
		   jms iwrite; ..; ..		" write to file
001031: 103257  
001032: 000000  
001033: 000000  
		exitrw:				" common exit for read/write system calls
		   dac u.ac			" save return in user AC
001034: 045631  
		   tad f.badd
001035: 345760  
		   dac f.badd			" update file offset
001036: 045760  
		   jms iput			" release inode
001037: 103046  
		   jms fput			" release fnode
001040: 102402  
		   jmp sysexit			" return to user
001041: 600103  
		"** 01-s1.pdf page 14
		" s3
			" search for user (process) table entry
			" call:
			"   jms searchu; worker_routine_addr
			" worker called with copy of a process table entry in "lu"
			"	can return directly (from caller of searchu)
			"	index location 8 points to next process table entry
		searchu: 0
001042: 000000  
		   lac searchu i		" fetch argument
001043: 221042  
		   dac 9f+t+1			" in t1
001044: 044207  
		   -mnproc			" loop counter
001045: 777766  
		   dac 9f+t			" in t0
001046: 044206  
		   law ulist-1			" ulist ptr
001047: 765560  
		   dac 8			" in index 8
001050: 040010  
		1:
		   lac 8 i			" copy ulist entry to lu
001051: 220010  
		   dac lu
001052: 045514  
		   lac 8 i
001053: 220010  
		   dac lu+1
001054: 045515  
		   lac 8 i
001055: 220010  
		   dac lu+2
001056: 045516  
		   lac 8 i
001057: 220010  
		   dac lu+3
001060: 045517  
		   jms 9f+t+1 i			" call argument as subroutine
001061: 124207  
		   isz 9f+t			" returned: loop done?
001062: 444206  
		   jmp 1b			"  no, do it again
001063: 601051  
		   isz searchu			" skip argument
001064: 441042  
		   jmp searchu i
001065: 621042  
		t = t+2
	000003  
			" look for a process with matching status
			"   jms lookfor; status
			"    found: ulist ptr in AC
			"   not found
		lookfor: 0
001066: 000000  
		   jms searchu; 1f
001067: 101042  
001070: 001074  
		   isz lookfor			" skip argument
001071: 441066  
		   isz lookfor			" give skip return
001072: 441066  
		   jmp lookfor i
001073: 621066  
		1: 0				" worker called by searchu
001074: 000000  
		   lac lu
001075: 205514  
		   rtl; rtl; and o7		" bits 0:2 of lu
001076: 742010  
001077: 742010  
001100: 504125  
		   sad lookfor i		" match argument?
001101: 561066  
		   skp				"  yes
001102: 741000  
		   jmp 1b i			"   no, return, keep going
001103: 621074  
		   -3
001104: 777775  
		   tad 8			" roll index 8 back to this entry
001105: 340010  
		   and o17777
001106: 504160  
		   isz lookfor			" skip lookfor argument
001107: 441066  
		   jmp lookfor i		" non-skip return
001110: 621066  
			" fork system call:
			"   sys fork
			"    return at +1 in parent, child pid in AC
			"   return at +2 in child, parent pid in AC
		.fork:
		   jms lookfor; 0 " not-used	" find an unused process slot
001111: 101066  
001112: 000000  
		      skp
001113: 741000  
		      jms error			" none found- return error
001114: 101531  
		   dac 9f+t			" save ulist ptr in t0
001115: 044210  
		   isz uniqpid			" generate new pid
001116: 445513  
		   lac uniqpid
001117: 205513  
		   dac u.ac			" return in child pid in AC
001120: 045631  
		   law sysexit
001121: 760103  
		   dac u.swapret		" return from system call when swapped back in
001122: 045650  
		   lac o200000			" change process status to out/ready (1->3)
001123: 204170  
		   tad u.ulistp i
001124: 365647  
		   dac u.ulistp i
001125: 065647  
		   jms dskswap; 07000		" swap parent out
001126: 102267  
001127: 007000  
		   lac 9f+t			" get unused ulist slot back
001130: 204210  
		   dac u.ulistp			" set ulist pointer
001131: 045647  
		   lac o100000			" mark child in/notready? (3->2)
001132: 204166  
		   xor u.ulistp i
001133: 265647  
		   dac u.ulistp i
001134: 065647  
		   lac u.pid			" get old (parent) pid
001135: 205645  
		"** 01-s1.pdf page 15
		   dac u.ac			" return parent pid in AC
001136: 045631  
		   lac uniqpid
001137: 205513  
		   dac u.pid			" set child pid
001140: 045645  
		   isz 9f+t			" advance to second word in process table
001141: 444210  
		   dac 9f+t i			" set pid in process table
001142: 064210  
		   isz u.rq+8			" give skip return
001143: 445643  
		   dzm u.intflg			" clear int flag
001144: 145713  
		   jmp sysexit			" return in child process
001145: 600103  
		t= t+1
	000004  
		badcal:				" bad (unimplemented) system call
		   clon				" clear any pending clock interrupt?
001146: 700044  
		   -1
001147: 777777  
		   dac 7			" set location 7 to -1?!
001150: 040007  
			" fall into "save" system call
			" Ken says save files could be resumed, and used for checkpointing!
		.save:				" "sys save" system call
		   lac d1			" get inode 1 (core file?)
001151: 204117  
		   jms iget
001152: 103017  
		   cla
001153: 750000  
		   jms iwrite; 4096; 4096	" dump core
001154: 103257  
001155: 010000  
001156: 010000  
		   jms iwrite; userdata; 64	" and user area
001157: 103257  
001160: 005631  
001161: 000100  
		   jms iput
001162: 103046  
		.exit:
		   lac u.dspbuf
001163: 205712  
		   sna				" process using display?
001164: 741200  
		   jmp .+3			"  no
001165: 601170  
		   law dspbuf			"   yes: get default display buffer
001166: 764446  
		   jms movdsp			"   move display
001167: 102615  
		   jms awake
001170: 101304  
		   lac u.ulistp i
001171: 225647  
		   and o77777			" mark process table entry free
001172: 504165  
		   dac u.ulistp i
001173: 065647  
		   isz u.ulistp
001174: 445647  
		   dzm u.ulistp i		" clear pid in process table
001175: 165647  
		   jms swap			" find a new process to run
001176: 100136  
			" exit falls into "rmes" !!!
			" rmes system call
			"   sys smes
			" returns with message delivered, or error if process does not exit
			" AC/ sending pid
			" MQ/ message
		.rmes:
		   jms awake
001177: 101304  
		   lac o100000			" mark this process "not ready"
001200: 204166  
		   tad u.ulistp i		" by incrementing status
001201: 365647  
		   dac u.ulistp i
001202: 065647  
		   law 2
001203: 760002  
		   tad u.ulistp
001204: 345647  
		   dac 9f+t			" pointer to msg status in proc table
001205: 044211  
		   -1
001206: 777777  
		   dac 9f+t i			" set to -1 (waiting for message)
001207: 064211  
		   jms swap			" switch processes
001210: 100136  
		   law 2
001211: 760002  
		   tad u.ulistp
001212: 345647  
		   dac 9f+t
001213: 044211  
		   lac 9f+t i			" get msg status word
001214: 224211  
		   cma				" complement (get sender pid)
001215: 740001  
		   dac u.ac			" return in user AC
001216: 045631  
		   dzm 9f+t i			" clear status word
001217: 164211  
		   isz 9f+t
001220: 444211  
		   lac 9f+t i			" get message
001221: 224211  
		   dac u.mq			" return in user MQ
001222: 045632  
		   dzm 9f+t i			" clear message
001223: 164211  
		   jmp sysexit
001224: 600103  
		t = t+1
	000005  
		"** 01-s1.pdf page 16
			" smes system call
			" AC/ pid
			" MQ/ message
			"   sys smes
			" returns with message delivered, or error if process does not exit
		.smes:
		   lac u.ac			" get pid from user AC
001225: 205631  
		   sna spa			" >0?
001226: 741300  
		   jms error			"  no: error
001227: 101531  
		   jms searchu; 1f		" search for process
001230: 101042  
001231: 001237  
		   law 2
001232: 760002  
		   tad u.ulistp
001233: 345647  
		   dac 9f+t
001234: 044212  
		   dzm 9f+t i
001235: 164212  
		   jms error
001236: 101531  
		1: 0				" worker for searchu
001237: 000000  
		   lac lu+1			" get pid
001240: 205515  
		   sad u.ac			" match?
001241: 545631  
		   skp				"  yes
001242: 741000  
		   jmp 1b i			"   no
001243: 621237  
		   lac lu+2			" get mailbox status
001244: 205516  
		   sad dm1			" -1?
001245: 544204  
		   jmp 1f			"  yes
001246: 601265  
		   lac o100000			" no: bump our process status (to notready?)
001247: 204166  
		   tad u.ulistp i
001250: 365647  
		   dac u.ulistp i
001251: 065647  
		   law 2
001252: 760002  
		   tad u.ulistp
001253: 345647  
		   dac 9f+t
001254: 044212  
		   lac u.ac
001255: 205631  
		   dac 9f+t i
001256: 064212  
		   jms swap
001257: 100136  
		   law 2
001260: 760002  
		   tad u.ulistp
001261: 345647  
		   dac 9f+t
001262: 044212  
		   dzm 9f+t i
001263: 164212  
		   jmp .smes
001264: 601225  
		1:
		   -3
001265: 777775  
		   tad 8
001266: 340010  
		   dac 9f+t			" pointer to dest process ulist entry
001267: 044212  
		   lac o700000			" complement process status? marks ready??
001270: 204200  
		   tad 9f+t i
001271: 364212  
		   dac 9f+t i
001272: 064212  
		   isz 9f+t
001273: 444212  
		   isz 9f+t			" point to mailbox word?
001274: 444212  
		   lac u.pid			" get our pid
001275: 205645  
		   cma				" complement
001276: 740001  
		   dac 9f+t i			" store in mailbox??
001277: 064212  
		   isz 9f+t			" advance to next word
001300: 444212  
		   lac u.mq			" get user MQ
001301: 205632  
		   dac 9f+t i			" save as message
001302: 064212  
		   jmp okexit
001303: 600102  
		t = t+1
	000006  
			" wake up process hanging on rmes for current process??
		awake: 0
001304: 000000  
		   jms searchu; 1f
001305: 101042  
001306: 001310  
		   jmp awake i
001307: 621304  
		1: 0				" searchu worker
001310: 000000  
		   lac u.pid			" get caller pid
001311: 205645  
		   sad lu+2			" match mailbox status?
001312: 545516  
		   skp				"  yes
001313: 741000  
		   jmp 1b i			"   no, return
001314: 621310  
		   -3
001315: 777775  
		   tad 8			" get pointer to process table entry
001316: 340010  
		   dac 9f+t			" save in t0
001317: 044213  
		"** 01-s1.pdf page 17
		   lac o700000
001320: 204200  
		   tad 9f+t i			" complement process status (mark ready)??
001321: 364213  
		   dac 9f+t i
001322: 064213  
		   jmp 1b i			" return from worker
001323: 621310  
		t = t+1
	000007  
		swr:
		sww:
		   jmp .-4 i
001324: 621320  
		   .halt; rttyi; rkbdi; rppti; .halt
001325: 001336  
001326: 001337  
001327: 001410  
001330: 001461  
001331: 001336  
		   .halt; wttyo; wdspo; wppto
001332: 001336  
001333: 001357  
001334: 001451  
001335: 001475  
		.halt: jms halt
001336: 102254  
			" read routine for ttyin special file
		rttyi:
		   jms chkint1
001337: 101535  
		   lac d1		" ** written d3 ttyin2
001340: 204117  
		   jms getchar
001341: 101745  
		      jmp 1f
001342: 601353  
		   and o177
001343: 504147  
		   jms betwen; o101; o132	" upper case?
001344: 101643  
001345: 004141  
001346: 004143  
		      skp			"  no
001347: 741000  
		   tad o40			"   yes: convert to lower
001350: 344136  
		   alss 9
001351: 660711  
		   jmp passone
001352: 601523  
		1:
		   jms sleep; sfiles+0
001353: 102434  
001354: 005520  
		   jms swap
001355: 100136  
		   jmp rttyi
001356: 601337  
			" write routine for ttyout special file
		wttyo:
		   jms chkint1
001357: 101535  
		   jms forall
001360: 102412  
		   sna
001361: 741200  
		   jmp fallr
001362: 602425  
		   lmq
001363: 652000  
		   lac sfiles+1
001364: 205521  
		   spa
001365: 741100  
		   jmp 1f
001366: 601376  
		   xor o400000
001367: 244173  
		   dac sfiles+1
001370: 045521  
		   lacq
001371: 641002  
		   tls				" load output buffer
001372: 700406  
		   sad o12			" newline?
001373: 544130  
		   jms putcr			"  yes, put CR as well
001374: 104014  
		   jmp fallr
001375: 602425  
		1:
		   lacq
001376: 641002  
		   dac char
001377: 045511  
		   lac d2	"** written: d6 ttyout
001400: 204120  
		   jms putchar
001401: 101730  
		      skp
001402: 741000  
		   jmp fallr
001403: 602425  
		   jms sleep; sfiles+1
001404: 102434  
001405: 005521  
		   jms swap
001406: 100136  
		   jmp wttyo
001407: 601357  
			" read routine for (display) "keyboard" special file
		rkbdi:
		   jms chkint1
001410: 101535  
		   lac d3
001411: 204121  
		   jms getchar
001412: 101745  
		"** 01-s1.pdf page 18
		      jmp 3f
001413: 601445  
		   lmq
001414: 652000  
		   and o155
001415: 504146  
		   sad o55
001416: 544137  
		   jmp 1f			" -/=? map to =?-/ ???
001417: 601425  
		   lacq
001420: 641002  
		   and o137
001421: 504145  
		   sad o134
001422: 544144  
		   skp				" \| map to Ll ???
001423: 741000  
		   jmp 2f
001424: 601430  
		1:
		   lacq
001425: 641002  
		   xor o20
001426: 244134  
		   lmq
001427: 652000  
		2:
		   lacq
001430: 641002  
		   dac u.limit
001431: 045653  
		1:
		   jms chkint1
001432: 101535  
		   lac u.limit
001433: 205653  
		   jms dspput
001434: 102540  
		      jmp 1f
001435: 601442  
		   jms sleep; sfiles+6
001436: 102434  
001437: 005526  
		   jms swap
001440: 100136  
		   jmp 1b
001441: 601432  
		1:
		   lac u.limit
001442: 205653  
		   alss 9
001443: 660711  
		   jmp passone
001444: 601523  
		3:
		   jms sleep; sfiles+2
001445: 102434  
001446: 005522  
		   jms swap
001447: 100136  
		   jmp rkbdi
001450: 601410  
			" write routine for (graphic) "display" special file
		wdspo:
		   jms chkint1
001451: 101535  
		   jms forall
001452: 102412  
		   jms dspput			" put char (fallr "returns" here)
001453: 102540  
		      jmp fallr			" go back for next (continuation!)
001454: 602425  
		   jms sleep; sfiles+6
001455: 102434  
001456: 005526  
		   jms swap
001457: 100136  
		   jmp wdspo
001460: 601451  
			" read routine for paper tape reader special file
		rppti:
		   lac d4
001461: 204122  
		   jms getchar
001462: 101745  
		      jmp .+3
001463: 601466  
		   alss 9
001464: 660711  
		   jmp passone
001465: 601523  
		   lac sfiles+3
001466: 205523  
		   sma
001467: 740100  
		   rsa
001470: 700104  
		1:
		   jms sleep; sfiles+3
001471: 102434  
001472: 005523  
		   jms swap
001473: 100136  
		   jmp rppti
001474: 601461  
		"** 01-s1.pdf page 19
			" write routine for paper tape punch special file
		wppto:
		   jms forall
001475: 102412  
		   sna
001476: 741200  
		   jmp fallr
001477: 602425  
		   lmq
001500: 652000  
		   lac sfiles+4
001501: 205524  
		   spa
001502: 741100  
		   jmp 1f
001503: 601511  
		   xor o400000
001504: 244173  
		   dac sfiles+4
001505: 045524  
		   lacq
001506: 641002  
		   psa
001507: 700204  
		   jmp fallr
001510: 602425  
		1:
		   lacq
001511: 641002  
		   dac char
001512: 045511  
		   lac d5
001513: 204123  
		   jms putchar
001514: 101730  
		      skp
001515: 741000  
		   jmp fallr
001516: 602425  
		   jms sleep; sfiles+4
001517: 102434  
001520: 005524  
		   jms swap
001521: 100136  
		   jmp wppto
001522: 601475  
			" common exit for special file input
		passone:
		   sad o4000			" CTRL/D?
001523: 544154  
		   jmp okexit			"  yes: return zero
001524: 600102  
		   dac u.base i			" no: save for user
001525: 065651  
		   lac d1			" return 1
001526: 204117  
		   dac u.ac
001527: 045631  
		   jmp sysexit
001530: 600103  
		error: 0
001531: 000000  
		   -1
001532: 777777  
		   dac u.ac
001533: 045631  
		   jmp sysexit
001534: 600103  
		chkint1: 0
001535: 000000  
		   dzm .insys
001536: 144066  
		   jms chkint
001537: 100320  
		      skp
001540: 741000  
		   jmp .save
001541: 601151  
		   -1
001542: 777777  
		   dac .insys
001543: 044066  
		   jmp chkint1 i
001544: 621535  
		"** 01-s1.pdf page 21
		" s4
			" allocate a free disk block for a file (data or indirect)
		alloc: 0
001545: 000000  
		   -1			" Decrement the # free block numbers in the cache
001546: 777777  
		   tad s.nfblks		" kept at s.fblks. Jump to 1f if no free blocks left.
001547: 345543  
		   spa
001550: 741100  
		   jmp 1f
001551: 601566  
		   dac s.nfblks		" Update the count of free block numbers
001552: 045543  
		   tad fblksp
001553: 344106  
		   jms laci
001554: 101635  
		   dac 9f+t
001555: 044214  
		   jms copyz; dskbuf; 64
001556: 101712  
001557: 007700  
001560: 000100  
		   lac 9f+t
001561: 204214  
		   jms dskwr
001562: 102146  
		   dzm .savblk
001563: 144072  
		   lac 9f+t
001564: 204214  
		   jmp alloc i		" Return from routine
001565: 621545  
		1:
		   lac s.nxfblk
001566: 205542  
		   sna
001567: 741200  
		   jms halt " OUT OF DISK
001570: 102254  
		   dac s.fblks
001571: 045544  
		   jms dskrd
001572: 102116  
		   lac dskbuf
001573: 207700  
		   dac s.nxfblk
001574: 045542  
		   jms copy; dskbuf+1; s.fblks+1; 9
001575: 101667  
001576: 007701  
001577: 005545  
001600: 000011  
		   lac d10
001601: 204130  
		   dac s.nfblks
001602: 045543  
		   jmp alloc+1
001603: 601546  
			" free the disk block whose number is in AC
		free: 0
001604: 000000  
		   lmq
001605: 652000  
		   lac s.nfblks
001606: 205543  
		   sad d10
001607: 544130  
		   jmp 1f
001610: 601620  
		   tad fblksp
001611: 344106  
		   dac 9f+t
001612: 044214  
		   lacq
001613: 641002  
		   dac 9f+t i
001614: 064214  
		   dzm .savblk
001615: 144072  
		   isz s.nfblks
001616: 445543  
		   jmp free i
001617: 621604  
		1:
		   lac s.nxfblk
001620: 205542  
		   dac dskbuf
001621: 047700  
		   jms copy; s.fblks+1; dskbuf+1; 9
001622: 101667  
001623: 005545  
001624: 007701  
001625: 000011  
		   lacq
001626: 641002  
		   dac s.nxfblk
001627: 045542  
		   jms dskwr
001630: 102146  
		   dzm .savblk
001631: 144072  
		   lac d1
001632: 204117  
		   dac s.nfblks
001633: 045543  
		   jmp free i				" Return from the routine
001634: 621604  
		t = t+1
	000010  
			" load AC indirect (without using indirect!)
			" AC/ address
			"   jms laci
			" AC/ contents of address
		laci: 0
001635: 000000  
		   and o17777				" clear everything but addr
001636: 504160  
		   tad o200000				" make into "lac addr"
001637: 344170  
		   dac .+1
001640: 041641  
		   lac ..				" fetch
001641: 200000  
		   jmp laci i				" return
001642: 621635  
		"** 01-s1.pdf page 22
			" skip if AC between two values (inclusive)
			"   jms betwen; low_ptr; high_ptr
			"    <not between>
			"  <between>
			" listing has an alternate written in
			"  (which would require 'lac ptr' instead of 'ptr' args?)
		betwen: 0
001643: 000000  
		   lmq cmq			" get ~AC in MQ
001644: 652004  
		   lac betwen i			" get low_ptr
001645: 221643  
		   dac 9f+t
001646: 044215  
		   isz betwen			" skip low_ptr
001647: 441643  
		   lacq				" get ~AC (-AC-1) from MQ
001650: 641002  
		   tad 9f+t i			" get low-AC-1
001651: 364215  
		   sma				" negative (AC >= low)?
001652: 740100  
		   jmp 1f			"  no, return w/o skip
001653: 601663  
		   lac betwen i			" fetch high_ptr
001654: 221643  
		   dac 9f+t
001655: 044215  
		   isz betwen			" skip high_ptr
001656: 441643  
		   lacq				" get -AC-1
001657: 641002  
		   tad 9f+t i			" add to high value (high-AC-1)
001660: 364215  
		   cma				" complement (AC-high)
001661: 740001  
		   spa sna			" AC-high <= 0?
001662: 741300  
		1:
		   isz betwen			"  no: give happy (skip) return
001663: 441643  
		   lacq				" restore ~AC
001664: 641002  
		   cma				" restore AC
001665: 740001  
		   jmp betwen i			" return w/o skip
001666: 621643  
			" copy memory
			" call:
			"   jms copy; src; dest; count
		copy: 0
001667: 000000  
		   -1
001670: 777777  
		   tad copy i
001671: 361667  
		   dac 8
001672: 040010  
		   isz copy
001673: 441667  
		   -1
001674: 777777  
		   tad copy i
001675: 361667  
		   dac 9
001676: 040011  
		   isz copy
001677: 441667  
		   -1
001700: 777777  
		   tad copy i
001701: 361667  
		   cma
001702: 740001  
		   dac 9f+t
001703: 044215  
		   isz copy
001704: 441667  
		1:
		   lac 8 i
001705: 220010  
		   dac 9 i
001706: 060011  
		   isz 9f+t
001707: 444215  
		   jmp 1b
001710: 601705  
		   jmp copy i
001711: 621667  
			" copy zeroes (clear memory)
			" call:
			"   jms copyz; pointer; count
		copyz: 0
001712: 000000  
		   -1
001713: 777777  
		   tad copyz i			" get call PC
001714: 361712  
		   dac 8			" save in index (pre-increments)
001715: 040010  
		   isz copyz			" skip pointer
001716: 441712  
		   -1
001717: 777777  
		   tad copyz i			" get count-1
001720: 361712  
		   cma				" get negative count
001721: 740001  
		   dac 9f+t			" save in t0
001722: 044215  
		   isz copyz			" skip count
001723: 441712  
		1:
		   dzm 8 i			" zero word
001724: 160010  
		   isz 9f+t			" done?
001725: 444215  
		   jmp 1b			"  no: loop
001726: 601724  
		   jmp copyz i			" return
001727: 621712  
		t = t+1
	000011  
			" put queued character
			" CALLED FROM PI: AVOIDS INDIRECT!!
			" queue number in AC
		putchar: 0
001730: 000000  
		"** 01-s1.pdf page 23
		   dac 9f+t
001731: 044216  
		   cla
001732: 750000  
		   jms takeq
001733: 101757  
		      jmp putchar i
001734: 621730  
		   tad o40001
001735: 344163  
		   dac .+4
001736: 041742  
		   lac 9f+t
001737: 204216  
		   jms putq
001740: 102011  
		   lac char
001741: 205511  
		   dac q2+1 ..
001742: 044301  
		   isz putchar
001743: 441730  
		   jmp putchar i
001744: 621730  
		t = t+1
	000012  
			" get queued character
			" CALLED FROM PI: AVOIDS INDIRECT!!
			" queue number in AC:
			"  1: tty input
			"  2: tty output
			"  3: display keyboard
			"  4: paper tape reader
			"  5: paper tape punch
		getchar: 0
001745: 000000  
		   jms takeq
001746: 101757  
		      jmp i getchar
001747: 621745  
		   tad o200001
001750: 344171  
		   dac .+3
001751: 041754  
		   cla
001752: 750000  
		   jms putq
001753: 102011  
		   lac q2+1 ..
001754: 204301  
		   isz getchar
001755: 441745  
		   jmp i getchar
001756: 621745  
			" CALLED FROM PI: AVOIDS INDIRECT!!
		takeq: 0
001757: 000000  
		   rcl
001760: 744010  
		   tad lacq1
001761: 344110  
		   dac .+7
001762: 041771  
		   tad o640000
001763: 344177  
		   dac .+17
001764: 042005  
		   tad d1
001765: 344117  
		   dac .+14
001766: 042004  
		   tad o500000
001767: 344174  
		   dac .+5
001770: 041775  
		   lac q1 ..
001771: 204260  
		   sna
001772: 741200  
		   jmp takeq i
001773: 621757  
		   dac lnkaddr
001774: 045510  
		   sad q1+1 ..
001775: 544261  
		   jmp .+5
001776: 602003  
		   tad o200000
001777: 344170  
		   dac .+1
002000: 042001  
		   lac q2 ..
002001: 204300  
		   jmp .+3
002002: 602005  
		   cla
002003: 750000  
		   dac q1+1 ..
002004: 044261  
		   dac q1 ..
002005: 044260  
		   isz takeq
002006: 441757  
		   lac lnkaddr
002007: 205510  
		   jmp i takeq
002010: 621757  
		putq: 0
002011: 000000  
		   rcl
002012: 744010  
		   tad dacq1
002013: 344107  
		   dac .+14
002014: 042032  
		   tad d1
002015: 344117  
		   dac .+13
002016: 042033  
		   tad o140000
002017: 344167  
		   dac .+1
002020: 042021  
		   lac q1-1 ..
002021: 204257  
		"** 01-s1.pdf page 24
		   sna
002022: 741200  
		   jmp .+6
002023: 602031  
		   tad o40000
002024: 344162  
		   dac .+2
002025: 042027  
		   lac lnkaddr
002026: 205510  
		   dac q2 ..
002027: 044300  
		   jmp .+3
002030: 602033  
		   lac lnkaddr
002031: 205510  
		   dac q1 ..
002032: 044260  
		   dac q1+1 ..
002033: 044261  
		   jmp putq i
002034: 622011  
		srcdbs: 0
002035: 000000  
		   dac 9f+t+2   "* lmq
002036: 044221  
		   -ndskbs
002037: 777774  
		   dac 9f+t
002040: 044217  
		   law dskbs	"* -1 dac 8 written
002041: 765067  
		   dac 9f+t+1	"* lacq
002042: 044220  
		1:
		   lac 9f+t+2	"** crossed out
002043: 204221  
		   sad 9f+t+1	"** isz 8 written
002044: 544220  
		   jmp srcdbs i
002045: 622035  
		   law 65	"** ??? crossed out
002046: 760101  
		   tad 9f+t+1	"** crossed out isz 8 written
002047: 344220  
		   isz 9f+t+1
002050: 444220  
		   isz 9f+t
002051: 444217  
		   jmp 1b
002052: 602043  
		   isz srcdbs
002053: 442035  
		   jmp srcdbs i
002054: 622035  
		collapse: 0
002055: 000000  
		   cla
002056: 750000  
		   jms srcdbs
002057: 102035  
		      jmp 1f
002060: 602063  
		   law dskbs
002061: 765067  
		   dac 9f+t+1	"** 9f+t+1 crossed out: 8 written in
002062: 044220  
		1:
		   lac 9f+t+1	"** 9f+t+1 crossed out: 8 written in
002063: 204220  
		   dac 0f+1
002064: 042100  
		   tad d65	"** crossed out: d2-- original obscured
002065: 344141  
		   dac 0f
002066: 042077  
		   cma
002067: 740001  
		   tad d1
002070: 344117  
		   tad edskbsp
002071: 345473  
		   and o17777
002072: 504160  
		   sna
002073: 741200  
		   jmp 0f+3
002074: 602102  
		   dac 0f+2
002075: 042101  
		   jms copy; 0:..; ..; ..
002076: 101667  
002077: 000000  
002100: 000000  
002101: 000000  
		   -65
002102: 777677  
		   tad edskbsp
002103: 345473  
		   dac 9f+t
002104: 044217  
		   tad d1
002105: 344117  
		   dac 0f
002106: 042113  
		   lac dskaddr
002107: 205512  
		   dac 9f+t i
002110: 064217  
		   jms copy; dskbuf; 0:..; 64
002111: 101667  
002112: 007700  
002113: 000000  
002114: 000100  
		   jmp collapse i
002115: 622055  
		dskrd: 0
002116: 000000  
		   jms betwen; d2; d7999
002117: 101643  
002120: 004120  
002121: 004155  
		"** 01-s1.pdf page 25
		      jms halt
002122: 102254  
		   sad dskaddr
002123: 545512  
		   jmp dskrd i
002124: 622116  
		   dac dskaddr
002125: 045512  
		   jms srcdbs
002126: 102035  
		      jmp 1f
002127: 602134  
		   lac dskaddr
002130: 205512  
		   jms dskio; 06000
002131: 102162  
002132: 006000  
		   jmp 2f
002133: 602144  
		1:
		   dzm 9f+t+1 i
002134: 164220  
		   law 1
002135: 760001  
		   tad 9f+t+1
002136: 344220  
		   dac .+2
002137: 042141  
		   jms copy; ..; dskbuf; 64
002140: 101667  
002141: 000000  
002142: 007700  
002143: 000100  
		2:
		   jms collapse
002144: 102055  
		   jmp dskrd i
002145: 622116  
			" write a file block (data, inode or indirect)
			" AC/ block
		dskwr: 0
002146: 000000  
		   jms betwen; d2; d7999
002147: 101643  
002150: 004120  
002151: 004155  
		      jms halt
002152: 102254  
		   jms dskio; 07000
002153: 102162  
002154: 007000  
		   lac dskaddr
002155: 205512  
		   jms srcdbs
002156: 102035  
		      dzm 9f+t+1 i
002157: 164220  
		   jms collapse
002160: 102055  
		   jmp dskwr i
002161: 622146  
		t = t+3
	000015  
			" AC/ block
			"   jms dskio; dsld_bits
		dskio: 0
002162: 000000  
		   dac dskaddr
002163: 045512  
		   cll; idiv; 80
002164: 744000  
002165: 653323  
002166: 000120  
		   dac 9f+t
002167: 044222  
		   lacq
002170: 641002  
		   idiv; 10
002171: 653323  
002172: 000012  
		   dac 9f+t+1
002173: 044223  
		   lls 22
002174: 640626  
		   xor 9f+t+1
002175: 244223  
		   als 8
002176: 640710  
		   dac 9f+t+1
002177: 044223  
		   lac 9f+t
002200: 204222  
		   idiv; 10
002201: 653323  
002202: 000012  
		   dac 9f+t
002203: 044222  
		   lls 22
002204: 640626  
		   xor 9f+t
002205: 244222  
		   xor 9f+t+1
002206: 244223  
		   xor o200000
002207: 244170  
		   dac 9f+t
002210: 044222  
		   jms dsktrans; -64; dskbuf; 9f+t; dskio
002211: 102220  
002212: 777700  
002213: 007700  
002214: 004222  
002215: 002162  
		   isz dskio
002216: 442162  
		   jmp dskio i
002217: 622162  
		t = t+1
	000016  
			" called with:
			"   jms dsktrans; -WC; MAC; addr_ptr?; dsld_ptr
		dsktrans: 0
002220: 000000  
		   -10
002221: 777766  
		   dac 9f+t
002222: 044223  
		1:
		   -1
002223: 777777  
		   tad dsktrans
002224: 342220  
		   dac 12
002225: 040014  
		"** 01-s1.pdf page 26
		   dscs				" clear status register
002226: 707141  
		   lac 12 i
002227: 220014  
		   dslw				" load WC
002230: 707124  
		   lac 12 i
002231: 220014  
		   dslm				" load MAC
002232: 707142  
		   lac 12 i
002233: 220014  
		   jms laci
002234: 101635  
		   dsld				" load TA & SA
002235: 707104  
		   dzm .dskb
002236: 144074  
		   lac 12 i
002237: 220014  
		   jms laci
002240: 101635  
		   jms laci
002241: 101635  
		   dsls				" load status
002242: 707144  
		   lac .dskb			" check for interrupt
002243: 204074  
		   sna
002244: 741200  
		   jmp .-2
002245: 602243  
		   lac .dske			" get status from interrupt
002246: 204075  
		   sma
002247: 740100  
		   jmp 12 i			" return
002250: 620014  
		   isz 9f+t
002251: 444223  
		   jmp 1b
002252: 602223  
		   jms halt " 10 disk errors
002253: 102254  
		t = t+1
	000017  
		halt: 0
002254: 000000  
		   isz 9f+t			" spin for a while (process interrupts)
002255: 444224  
		   jmp .-1
002256: 602255  
		   iof				" disable interrupts
002257: 700002  
		   hlt				" halt
002260: 740040  
		   jms copy; law; 4096; 4096	" continued: copy system up to user memory?
002261: 101667  
002262: 760000  
002263: 010000  
002264: 010000  
		   hlt; jmp .-1			" halt for good
002265: 740040  
002266: 602265  
		t = t+1
	000020  
		"** 01-s1.pdf page 28
		" s5
			" read/write a process from/to swap space
			" call:
			" AC/ first word of process table
			"   jms dskswap; DSLD bits
		dskswap: 0
002267: 000000  
		   cll; als 3			" get process disk address
002270: 744000  
002271: 640703  
		   dac 9f+t			" save in t0
002272: 044225  
		   jms dsktrans; -64; userdata; 9f+t; dskswap	" read/write user area
002273: 102220  
002274: 777700  
002275: 005631  
002276: 004225  
002277: 002267  
		   lac 9f+t			" get swap addr back
002300: 204225  
		   tad o20			" advance by 16??
002301: 344134  
		   dac 9f+t			" save
002302: 044225  
		   jms dsktrans; -4096; 4096; 9f+t; dskswap	" read/write user memory
002303: 102220  
002304: 770000  
002305: 010000  
002306: 004225  
002307: 002267  
		   isz dskswap			" skip bits
002310: 442267  
		   jmp dskswap i		" return
002311: 622267  
		t = t+1
	000021  
		access: 0
002312: 000000  
		   lac i.flags			" get inode flags
002313: 205732  
		   lmq				" save in MQ
002314: 652000  
		   lac u.uid			" get user id
002315: 205644  
		   spa				" negative?
002316: 741100  
		   jmp access i			"  yes: super user, return
002317: 622312  
		   sad i.uid			" compare to file owner
002320: 545742  
		   lrs 2			"  same: shift flags down two
002321: 640502  
		   lacq				" get inode flags back
002322: 641002  
		   and mode			" AND with mode from system call
002323: 505500  
		   sza				" access allowed?
002324: 740200  
		   jmp access i			"  yes: return
002325: 622312  
		   jms error			" no: return error from system call
002326: 101531  
		fassign: 0
002327: 000000  
		   -10				" loop count
002330: 777766  
		   dac 9f+t			" in t0
002331: 044226  
		1:
		   lac 9f+t			" get count
002332: 204226  
		   tad d10			" turn into fd
002333: 344130  
		   jms fget			" fetch open file into "fnode"
002334: 102360  
		      jms halt " will not happen
002335: 102254  
		   lac f.flags			" get fnode flags
002336: 205757  
		   sma				" sign bit set (active)?
002337: 740100  
		   jmp 1f			"  no: free
002340: 602344  
		   isz 9f+t			" increment loop count & loop until zero
002341: 444226  
		   jmp 1b
002342: 602332  
		   jmp fassign i
002343: 622327  
		1:
		   lac mode			" get mode from system call
002344: 205500  
		   xor o400000			" set sign bit
002345: 244173  
		   dac f.flags			" save in fnode
002346: 045757  
		   lac ii			" get i-number
002347: 205731  
		   dac f.i			" save in fnode
002350: 045761  
		   lac 9f+t
002351: 204226  
		   tad d10			" get fd
002352: 344130  
		   dac u.ac			" return in user AC
002353: 045631  
		   dzm f.badd			" clear file offset in fnode
002354: 145760  
		   jms fput			" copy fnode back into u.ofiles
002355: 102402  
		   isz fassign			" give skip return
002356: 442327  
		   jmp fassign i
002357: 622327  
		t = t+1
	000022  
			" load fnode (open file entry) from u.ofiles
			" AC/ user fd
			"   jms fget
			"    bad fd
			"   return with fnode set
		fget: 0
002360: 000000  
		   jms betwen; d0; d9		" fd 0..9?
002361: 101643  
002362: 004116  
002363: 004127  
		      jmp fget i		"  no, return
002364: 622360  
		   cll; mul; 3			" multiply by three
002365: 744000  
002366: 653122  
002367: 000003  
		   lacq
002370: 641002  
		"** 01-s1.pdf page 29
		   tad ofilesp			" get pointer into u.ofiles
002371: 344101  
		   dac 9f+t			" save in t0
002372: 044227  
		   dac .+2			" save as copy source
002373: 042375  
		   jms copy; ..; fnode; 3	" copy to "fnode"
002374: 101667  
002375: 000000  
002376: 005757  
002377: 000003  
		   isz fget			" give skip return
002400: 442360  
		   jmp fget i
002401: 622360  
			" copy fnode back to u.ofiles
			" uses temp value set by "fget"
			" (fget and fput calls must be paired)
		fput: 0
002402: 000000  
		   lac 9f+t
002403: 204227  
		   dac .+3
002404: 042407  
		   jms copy; fnode; ..; 3
002405: 101667  
002406: 005757  
002407: 000000  
002410: 000003  
		   jmp fput i
002411: 622402  
		t = t+1
	000023  
			" helper for special device write routines
			" return to caller with next character to write:
			" when done return character count to user.
		forall: 0
002412: 000000  
		   lac u.base
002413: 205651  
		   sad u.limit
002414: 545653  
		   jmp 1f			" done
002415: 602431  
		   lac u.base			" get base pointer (again?)
002416: 205651  
		   ral				" rotate MSB into LINK
002417: 740010  
		   lac u.base i			" fetch word via base pointer
002420: 225651  
		   snl				" link set?
002421: 740400  
		   lrs 9			"  no: get low 9 bits
002422: 640511  
		   and o777			" mask to 9 bits
002423: 504152  
		   jmp forall i			" return char
002424: 622412  
		fallr:				" jump here for subsequent characters
		   lac u.base			" get base
002425: 205651  
		   add o400000			" advance pointer
002426: 304173  
		   dac u.base			" start from top
002427: 045651  
		   jmp forall+1
002430: 602413  
		1:
		   lac u.count
002431: 205652  
		   dac u.ac
002432: 045631  
		   jmp sysexit
002433: 600103  
			" wait for a condition variable
			" call:
			"   jmr sleep; sfiles+N
		sleep: 0
002434: 000000  
		   law ulist-1		" pointer to process table
002435: 765560  
		   dac 8		" in index register
002436: 040010  
		   lac o200000
002437: 204170  
		   lmq			" get 200000 in MQ
002440: 652000  
		1:
		   lac u.ulistp i	" get current process status word
002441: 225647  
		   sad 8 i		" compare to next process table entry
002442: 560010  
		   jmp 1f		"  match
002443: 602452  
		   isz 8		" no match: skip other 3 words of process table
002444: 440010  
		   isz 8
002445: 440010  
		   isz 8
002446: 440010  
		   cla; lrs 1		" shift MQ down one
002447: 750000  
002450: 640501  
		   jmp 1b		" loop
002451: 602441  
		1:
		   tad o100000		" mark process not ready
002452: 344166  
		   dac u.ulistp i
002453: 065647  
		   lac sleep i		" get sleep variable pointer
002454: 222434  
		   dac 9f+t
002455: 044230  
		   lac 9f+t i		" get sleep variable contents
002456: 224230  
		   omq			" or in MQ (bit vector of processes waiting)
002457: 640002  
		   dac 9f+t i		" save
002460: 064230  
		   isz sleep		" skip sleep variable pointer
002461: 442434  
		   jmp sleep i
002462: 622434  
		t = t+1
	000024  
		"** 01-s1.pdf page 30
			" look for a free directory entry??
		dslot: 0
002463: 000000  
		   dzm di
002464: 145746  
		   skp
002465: 741000  
		1:
		   isz di
002466: 445746  
		   lac di
002467: 205746  
		   jms dget			" get directory entry
002470: 103104  
		   lac d.i			" get i number
002471: 205747  
		   sza				" zero (free)?
002472: 740200  
		   jmp 1b			"  no keep looking
002473: 602466  
		   jmp dslot i			" yes: return index
002474: 622463  
			" called with:
			" AC/ mode
			" name/ file name
		icreat: 0
002475: 000000  
		   dac 9f+t			" save mode in t0
002476: 044231  
		   jms dslot
002477: 102463  
		   lac o20			" look for a free inode starting at 17
002500: 204134  
		   dac ii
002501: 045731  
		1:
		   isz ii
002502: 445731  
		   lac ii
002503: 205731  
		   jms iget
002504: 103017  
		   lac i.flags
002505: 205732  
		   spa				" "in use" bit bit clear?
002506: 741100  
		   jmp 1b			"  no, guess again
002507: 602502  
		   lac ii
002510: 205731  
		   dac d.i
002511: 045747  
		   jms copy; name; d.name; 4
002512: 101667  
002513: 005504  
002514: 005750  
002515: 000004  
		   isz s.uniq			" get a new unique number
002516: 445556  
		   lac s.uniq
002517: 205556  
		   dac d.uniq			" save in directory entry
002520: 045754  
		   dac i.uniq			" and inode
002521: 045745  
		   lac 9f+t			" get mode
002522: 204231  
		   xor o400000			" set "in use"
002523: 244173  
		   dac i.flags
002524: 045732  
		   lac u.uid			" get user
002525: 205644  
		   dac i.uid			" set owner
002526: 045742  
		   -1
002527: 777777  
		   dac i.nlks			" -1 links?!
002530: 045743  
		   dzm i.size			" empty
002531: 145744  
		   jms copyz; i.dskps; 7	" clear disk block numbers
002532: 101712  
002533: 005733  
002534: 000007  
		   jms iput			" write inode
002535: 103046  
		   jms dput			" write directory entry
002536: 103136  
		   jmp icreat i
002537: 622475  
		t = t+1
	000025  
			" output character to display
		dspput: 0
002540: 000000  
		   and o177			" mask to 7 bits
002541: 504147  
		   sna
002542: 741200  
		   jmp i dspput			" discard NUL
002543: 622540  
		   sad o14			" Form Feed?
002544: 544131  
		   jmp 1f			"  yes
002545: 602560  
		   lmq				" save char in MQ
002546: 652000  
		   sad o12			" newline?
002547: 544130  
		   jms dspnl			"  yes
002550: 102574  
		   lac dsploc i			" get display word
002551: 224444  
		   sad o400000			" TRAP?
002552: 544173  
		   jmp dspleft			"  yes (first character)
002553: 602562  
		   omq				" no: or in second character
002554: 640002  
		   dac dsploc i			" save both characters
002555: 064444  
		   isz dsploc			" advance display pointer
002556: 444444  
		   jmp i dspput
002557: 622540  
		"** 01-s1.pdf page 31
		1:				" here on form feed
		   jms dspinit			" clear display
002560: 102606  
		   jmp dspput i
002561: 622540  
		dspleft:
		   lac dsploc			" get display pointer
002562: 204444  
		   sad edspbuf			" end of the buffer?
002563: 544104  
		   jmp 1f			"  yes: light up a button!?
002564: 602602  
		   dac 8			" no: store in index
002565: 040010  
		   lac o400000			" get TRAP instruction
002566: 204173  
		   dac 8 i			" store as next
002567: 060010  
		   cla; llss 18+7		" shift MQ upto "char1" position
002570: 750000  
002571: 660631  
		   dac dsploc i			" store word with char1
002572: 064444  
		   jmp dspput i
002573: 622540  
		dspnl: 0			" only called once!
002574: 000000  
		   lac dsplno			" get display line number
002575: 204445  
		   sad d33			" 33?
002576: 544142  
		   jmp 1f			"  yes: light a button!
002577: 602602  
		   isz dsplno			" no: increment line number
002600: 444445  
		   jmp dspnl i
002601: 622574  
		1:
		   lac o2000			" get bit for push button 7
002602: 204153  
		   wbl				" write button lights
002603: 704424  
		   isz dspput
002604: 442540  
		   jmp dspput i
002605: 622540  
		dspinit: 0
002606: 000000  
		   lac dspbufp3			" get pointer to dspbuf+3
002607: 204105  
		   dac dsploc			" store location
002610: 044444  
		   lac o400000			" display "TRAP" instruction (end of list)
002611: 204173  
		   dac dspbuf+3			" save in buffer
002612: 044451  
		   dzm dsplno			" clear display line number
002613: 144445  
		   jmp dspinit i
002614: 622606  
			" "move display" (change display buffer pointer)
			" called with new buffer pointer in AC??
		movdsp: 0
002615: 000000  
		   iof
002616: 700002  
		   cdf
002617: 700501  
		   dac dspbufp
002620: 045475  
		   -1
002621: 777777  
		   dac .dspb
002622: 045536  
		   ion
002623: 700042  
		   jmp movdsp i
002624: 622615  
			" fetch user argument from word after "sys" call, return in AC
		arg: 0
002625: 000000  
		   lac u.rq+8 i			" fetch word after return PC
002626: 225643  
		   isz u.rq+8			" bump PC
002627: 445643  
		   jmp arg i
002630: 622625  
			" fetch user pathname argument from pointer word after "sys" call
			" into "name" and look it up (in current working directory)
			" if lookup fails: returns error to user (not caller)
			" if lookup OK: returns with file i-inode read (into "inode")
			"	and i-number in AC
		argname: 0
002631: 000000  
		   jms arg			" fetch name pointer
002632: 102625  
		   dac .+2			" save as copy source
002633: 042635  
		   jms copy; ..; name; 4	" copy to "name"
002634: 101667  
002635: 000000  
002636: 005504  
002637: 000004  
		   lac u.cdir			" get CWD
002640: 205646  
		   jms namei; name		" look up file
002641: 102737  
002642: 005504  
		      jms error			"  failed: return error directly to user
002643: 101531  
		   jmp argname i
002644: 622631  
		seektell: 0
002645: 000000  
		   jms arg
002646: 102625  
		   dac u.base
002647: 045651  
		"** 01-s1.pdf page 32
		   jms arg
002650: 102625  
		   dac u.limit
002651: 045653  
		   jms finac
002652: 103370  
		   lac u.limit
002653: 205653  
		   sna
002654: 741200  
		   jmp seektell i
002655: 622645  
		   sad d1
002656: 544117  
		   jmp .+3
002657: 602662  
		   lac i.size
002660: 205744  
		   jmp seektell i
002661: 622645  
		   lac f.badd
002662: 205760  
		   jmp seektell i
002663: 622645  
			" system call helper
			" fetch system call argument name pointer from after "sys" call
			" read inode; if current user is not owner, return error to user
		isown: 0
002664: 000000  
		   jms argname
002665: 102631  
		   jms iget
002666: 103017  
		   lac u.uid			" get user id
002667: 205644  
		   sma				" super user?
002670: 740100  
		   sad i.uid			"  no: does user own file?
002671: 545742  
		   skp				"   yes, or super user
002672: 741000  
		   jms error			"    not super user, not owner: return error
002673: 101531  
		   jmp isown i
002674: 622664  
		"** 01-s1.pdf page 34
		" s6
		itrunc: 0
002675: 000000  
		   -7					" loop 7 times
002676: 777771  
		   dac 9f+t				" in t0
002677: 044232  
		   lac idskpp				" pointer to inode block numbers
002700: 204102  
		   dac 9f+t+1				" save in t1
002701: 044233  
		1:			" top of loop for inode blocks
		   lac 9f+t+1 i				" fetch next block number
002702: 224233  
		   sna					" allocated?
002703: 741200  
		   jmp 4f				"  no
002704: 602730  
		   lac i.flags				" check flags
002705: 205732  
		   and o200000				
002706: 504170  
		   sna					" large file?
002707: 741200  
		   jmp 3f				"  no
002710: 602725  
		   -64					" loop 64 times
002711: 777700  
		   dac 9f+t+2				" save count in t2
002712: 044234  
		   lac dskbufp				" get pointer to dskbuf
002713: 204103  
		   dac 9f+t+3				" in t3
002714: 044235  
		2:			" inner loop for indirect blocks
		   lac 9f+t+1 i				" get indirect block number
002715: 224233  
		   jms dskrd				" read it
002716: 102116  
		   lac 9f+t+3 i				" read block number from indirect
002717: 224235  
		   sza					" free?
002720: 740200  
		   jms free				"  no: free it
002721: 101604  
		   isz 9f+t+3				" increment pointer into indirect block
002722: 444235  
		   isz 9f+t+2				" increment loop counter, skip if done
002723: 444234  
		   jmp 2b				"  not done: loop
002724: 602715  
		3:			" here with small file
		   lac 9f+t+1 i				" load block number
002725: 224233  
		   jms free				" free it
002726: 101604  
		   dzm 9f+t+1 i				" clear block number
002727: 164233  
		4:			" bottom of loop for inode block ptrs
		   isz 9f+t+1				" increment block pointer
002730: 444233  
		   isz 9f+t				" increment count, skip if done
002731: 444232  
		   jmp 1b				"  not done
002732: 602702  
		   lac i.flags
002733: 205732  
		   and o577777				" clear large file flag
002734: 504175  
		   dac i.flags
002735: 045732  
		   jmp itrunc i
002736: 622675  
		t = t+4
	000031  
					" Given a pointer to a 4-word filename after
					" the jms to namei, and with AC holding the
					" i-num of the directory it is in, return the
					" i-number of the filename (and skip)
					" return zero in AC if not found (no skip)
		namei: 0
002737: 000000  
		   jms iget		" Get the inode from the i-num in the AC
002740: 103017  
		   -1
002741: 777777  
		   tad namei i		" get argptr-1
002742: 362737  
		   dac 9f+t+1		" save in t1
002743: 044237  
		   isz namei		" skip over argument
002744: 442737  
		   lac i.flags
002745: 205732  
		   and o20		" get directory bit
002746: 504134  
		   sna			" Is this a directory?
002747: 741200  
		   jmp namei i		"  no: return without skip
002750: 622737  
		   -8
002751: 777770  
		   tad i.size		" Subtract 8 from the file's size
002752: 345744  
		   cma
002753: 740001  
		   lrss 3
002754: 660503  
		   dac 9f+t		" negative count of directory entries in t0
002755: 044236  
		   sna			" any?
002756: 741200  
		   jmp namei i		"  no: return without skip
002757: 622737  
		   dzm di		" Store zero in di
002760: 145746  
		1:
		   lac di
002761: 205746  
		"** 01-s1.pdf page 35
		   jms dget		" Get a directory entry from the dirblock
002762: 103104  
		   lac d.i		" get i-num
002763: 205747  
		   sna			" in use?
002764: 741200  
		   jmp 2f		"  no
002765: 603013  
		   lac 9f+t+1		" get argptr-1
002766: 204237  
		   dac 8
002767: 040010  
		   lac d.name		" Compare the four words of the filename in the
002770: 205750  
		   sad 8 i		" directory entry with the argument to namei
002771: 560010  
		   skp
002772: 741000  
		   jmp 2f		" No match
002773: 603013  
		   lac d.name+1
002774: 205751  
		   sad 8 i
002775: 560010  
		   skp
002776: 741000  
		   jmp 2f		" No match
002777: 603013  
		   lac d.name+2
003000: 205752  
		   sad 8 i
003001: 560010  
		   skp
003002: 741000  
		   jmp 2f		" No match
003003: 603013  
		   lac d.name+3
003004: 205753  
		   sad 8 i
003005: 560010  
		   skp
003006: 741000  
		   jmp 2f		" No match
003007: 603013  
		   lac d.i		" A match. Get the i-number into AC
003010: 205747  
		   isz namei		" give skip return
003011: 442737  
		   jmp namei i
003012: 622737  
		2:
		   isz di		" No match, move up to the next direntry
003013: 445746  
		   isz 9f+t		" any left?
003014: 444236  
		   jmp 1b		"  yes: keep going
003015: 602761  
		   jmp namei i		" Didn't find it, return zero in AC (without skip)
003016: 622737  
		t = t+2
	000033  
		                        " Given an i-number in AC, fetch that i-node
		                        " from disk and store it in the inode buffer
		iget: 0
003017: 000000  
		   dac ii		" Store the i-number in ii
003020: 045731  
		   cll; idiv; 5		" Divide by 5: 5 inodes in a block
003021: 744000  
003022: 653323  
003023: 000005  
		   dac 9f+t		" Store the remainder in 9f+t: the i-node
003024: 044240  
		   lacq			" number within the block
003025: 641002  
		   tad d2		" Add 2 to the quotient to get the block number
003026: 344120  
		   dac 9f+t+1		" and store in 9f+t+1
003027: 044241  
		   jms dskrd		" Get the block
003030: 102116  
		   lac 9f+t
003031: 204240  
		   cll; mul; 12		" Multiply the i-num within the block by 12
003032: 744000  
003033: 653122  
003034: 000014  
		   lacq			" to get the offset into the block
003035: 641002  
		   tad dskbufp		" Add on the base of the disk buffer
003036: 344103  
		   dac 9f+t
003037: 044240  
		   dac .+2
003040: 043042  
		   jms copy; ..; inode; 12	" Copy 12 words from buffer to inode
003041: 101667  
003042: 000000  
003043: 005732  
003044: 000014  
		   jmp iget i		" and return
003045: 623017  
		iput: 0
003046: 000000  
		   lac 9f+t+1
003047: 204241  
		   jms dskrd
003050: 102116  
		   law inode-1
003051: 765731  
		   dac 8
003052: 040010  
		   -1
003053: 777777  
		   tad 9f+t
003054: 344240  
		   dac 9
003055: 040011  
		   -12
003056: 777764  
		   dac 9f+t+2
003057: 044242  
		1:
		   lac 8 i
003060: 220010  
		"** 01-s1.pdf page 36
		   sad 9 i
003061: 560011  
		   skp
003062: 741000  
		   jmp 2f
003063: 603067  
		   isz 9f+t+2
003064: 444242  
		   jmp 1b
003065: 603060  
		   jmp iput i
003066: 623046  
		2:
		   -1
003067: 777777  
		   tad 8
003070: 340010  
		   dac 8
003071: 040010  
		   -1
003072: 777777  
		   tad 9
003073: 340011  
		   dac 9
003074: 040011  
		1:
		   lac 8 i
003075: 220010  
		   dac 9 i
003076: 060011  
		   isz 9f+t+2
003077: 444242  
		   jmp 1b
003100: 603075  
		   lac 9f+t+1
003101: 204241  
		   jms dskwr
003102: 102146  
		   jmp iput i
003103: 623046  
		t = t+3
	000036  
			" allocate directory entry
			" AC/ entry number
		dget: 0
003104: 000000  
		   dac di			" save entry number
003105: 045746  
		   alss 3			" get word number
003106: 660703  
		   dac 9f+t			" save in t0
003107: 044243  
		   jms pget			" get free disk block
003110: 103152  
		   dac 9f+t+1			" save in t1
003111: 044244  
		   jms dskrd
003112: 102116  
		   lac 9f+t
003113: 204243  
		   and o77
003114: 504140  
		   tad dskbufp
003115: 344103  
		   dac 9f+t+2
003116: 044245  
		   dac .+2
003117: 043121  
		   jms copy; ..; dnode; 8
003120: 101667  
003121: 000000  
003122: 005747  
003123: 000010  
		   lac 9f+t
003124: 204243  
		   tad d8
003125: 344126  
		   jms betwen; d0; i.size
003126: 101643  
003127: 004116  
003130: 005744  
		      skp
003131: 741000  
		   jmp dget i
003132: 623104  
		   jms dacisize
003133: 103402  
		   dzm d.i
003134: 145747  
		   jmp dget i
003135: 623104  
		dput: 0
003136: 000000  
		   lac 9f+t+1
003137: 204244  
		   jms dskrd
003140: 102116  
		   lac 9f+t+2
003141: 204245  
		   dac .+3
003142: 043145  
		   jms copy; dnode; ..; 8
003143: 101667  
003144: 005747  
003145: 000000  
003146: 000010  
		   lac 9f+t+1
003147: 204244  
		   jms dskwr
003150: 102146  
		   jmp dput i
003151: 623136  
		t = t+3
	000041  
			" get a block number for a file, returns disk block number
			" allocates block if not allocated
			" AC/ file offset
			"   jms pget
			" AC/ disk block number
		pget: 0
003152: 000000  
		   lrss 6				" convert offset to block
003153: 660506  
		   dac 9f+t				" save as t0
003154: 044246  
		   lac i.flags
003155: 205732  
		"** 01-s1.pdf page 37
		   and o200000
003156: 504170  
		   sza					" large file bit set?
003157: 740200  
		   jmp 2f				"  yes
003160: 603220  
		   lac 9f+t				" no: small file
003161: 204246  
		   jms betwen; d0; d6			" block 0..6?
003162: 101643  
003163: 004116  
003164: 004124  
		      jmp 1f				"  no
003165: 603175  
		   tad idskpp				" make into block number pointer
003166: 344102  
		   dac 9f+t				" save in t0
003167: 044246  
		   lac 9f+t i				" get disk block number
003170: 224246  
		   sna					" allocated?
003171: 741200  
		   jms alloc				"  no: allocate now
003172: 101545  
		   dac 9f+t i				" save (new) disk block number
003173: 064246  
		   jmp pget i				" return disk block number
003174: 623152  
		1:					" here when file block>=7, not "large"
		   jms alloc				" allocate indirect block
003175: 101545  
		   dac 9f+t+1				" save as t1
003176: 044247  
		   jms copy; i.dskps; dskbuf; 7		" copy all the disk block numbers
003177: 101667  
003200: 005733  
003201: 007700  
003202: 000007  
		   jms copyz; dskbuf+7; 64-7		" zero rest of indirect block
003203: 101712  
003204: 007707  
003205: 000071  
		   lac 9f+t+1				" get indirect block number back
003206: 204247  
		   jms dskwr				" write indirect block to disk
003207: 102146  
		   lac 9f+t+1
003210: 204247  
		   dac i.dskps				" save indirect as new first block
003211: 045733  
		   jms copyz; i.dskps+1; 6		" zero rest of block pointers
003212: 101712  
003213: 005734  
003214: 000006  
		   lac i.flags
003215: 205732  
		   xor o200000				" set "large file"
003216: 244170  
		   dac i.flags
003217: 045732  
		2:					" here with "large file"
		   lac 9f+t				" get file block number
003220: 204246  
		   lrss 6				" divide by 64 (indirects/block)
003221: 660506  
		   jms betwen; d0; d6			" ok now?
003222: 101643  
003223: 004116  
003224: 004124  
		      jms halt " file too big		"  no, you lose!
003225: 102254  
		   tad idskpp				" yes: get indirect block pointer
003226: 344102  
		   dac 9f+t+1				" save in t1
003227: 044247  
		   lac 9f+t+1 i				" get indirect block number
003230: 224247  
		   sna					" allocated?
003231: 741200  
		   jms alloc				"  no, get it now
003232: 101545  
		   dac 9f+t+1 i				" save (new) indirect block
003233: 064247  
		   dac 9f+t+2				" save as t2
003234: 044250  
		   jms dskrd				" read indirect block
003235: 102116  
		   lac 9f+t				" get original block number
003236: 204246  
		   and o77				" mod by 64
003237: 504140  
		   tad dskbufp				" get pointer to disk block number
003240: 344103  
		   dac 9f+t+1				" save as t1
003241: 044247  
		   lac 9f+t+1 i				" fetch disk block number
003242: 224247  
		   sza					" allocated?
003243: 740200  
		   jmp pget i				"  yes: return
003244: 623152  
		   jms alloc				" no: allocate data block
003245: 101545  
		   dac 9f+t				" save as t0
003246: 044246  
		   lac 9f+t+2				" get indirect block number
003247: 204250  
		   jms dskrd				" read it in
003250: 102116  
		   lac 9f+t				" get data block number
003251: 204246  
		   dac 9f+t+1 i				" save data block number
003252: 064247  
		   lac 9f+t+2
003253: 204250  
		   jms dskwr				" write indirect block back
003254: 102146  
		   lac 9f+t				" get data block back
003255: 204246  
		   jmp pget i				" return it
003256: 623152  
		t = t+3
	000044  
		iwrite: 0
003257: 000000  
		   dac 9f+t				" save arg in t0
003260: 044251  
		   lac iwrite				" load return address
003261: 203257  
		"** 01-s1.pdf page 38
		   dac iread				" save as iread return addr
003262: 043266  
		   lac cskp				" load skip instruction
003263: 203335  
		   dac iwrite				" save as iwrite instruction
003264: 043257  
		   jmp 1f
003265: 603272  
			" iread from file referenced by loaded inode
			" AC/ file offset
			"    jms iread; addr; count
		iread: 0
003266: 000000  
		   dac 9f+t				" save offset in t0
003267: 044251  
		   lac cnop				" get nop
003270: 203442  
		   dac iwrite				" save as iwrite instruction
003271: 043257  
		1:
		   -1
003272: 777777  
		   tad iread i				" get word before return addr
003273: 363266  
		   dac 10				" store in index 10 & 11
003274: 040012  
		   dac 11
003275: 040013  
		   isz iread				" increment return addr
003276: 443266  
		   lac iread i				" load addr
003277: 223266  
		   dac 9f+t+1				" save in t1
003300: 044252  
		   isz iread				" increment return addr
003301: 443266  
		   lac o70000
003302: 204164  
		   xct iwrite				" skip if write
003303: 403257  
		   lac i.size				"  read: get file size
003304: 205744  
		   cma
003305: 740001  
		   tad 9f+t				" add offset
003306: 344251  
		   cma
003307: 740001  
		   jms betwen; d0; 9f+t+1
003310: 101643  
003311: 004116  
003312: 004252  
		      lac 9f+t+1
003313: 204252  
		   dac 9f+t+2
003314: 044253  
		   cma
003315: 740001  
		   tad d1
003316: 344117  
		   sna
003317: 741200  
		   jmp iread i
003320: 623266  
		   dac 9f+t+1
003321: 044252  
		1:
		   lac 9f+t
003322: 204251  
		   jms pget
003323: 103152  
		   dac 9f+t+3
003324: 044254  
		   jms dskrd
003325: 102116  
		   lac 9f+t
003326: 204251  
		   and o77
003327: 504140  
		   tad dskbufp
003330: 344103  
		   tad dm1
003331: 344204  
		   xct iwrite
003332: 403257  
		   jmp .+3
003333: 603336  
		   dac 10
003334: 040012  
		cskp:
		   skp
003335: 741000  
		   dac 11
003336: 040013  
		2:
		   lac 11 i
003337: 220013  
		   dac 10 i
003340: 060012  
		   isz 9f+t
003341: 444251  
		   isz 9f+t+1
003342: 444252  
		   jmp 3f
003343: 603357  
		      xct iwrite
003344: 403257  
		      jmp 4f
003345: 603355  
		      lac 9f+t
003346: 204251  
		      jms betwen; d0; i.size
003347: 101643  
003350: 004116  
003351: 005744  
		         dac i.size
003352: 045744  
		      lac 9f+t+3
003353: 204254  
		      jms dskwr
003354: 102146  
		   4:
		"** 01-s1.pdf page 38
		      lac 9f+t+2
003355: 204253  
		      jmp iread i
003356: 623266  
		3:
		   lac 9f+t
003357: 204251  
		   and o77
003360: 504140  
		   sza
003361: 740200  
		   jmp 2b
003362: 603337  
		   xct iwrite
003363: 403257  
		   jmp 1b
003364: 603322  
		   lac 9f+t+3
003365: 204254  
		   jms dskwr
003366: 102146  
		   jmp 1b
003367: 603322  
		t = t+4
	000050  
			" system call helper
			" AC/ fd
			"   jms finac
			" return with: fnode and inode loaded
			"	or makes error return to user
		finac: 0
003370: 000000  
		   lac u.ac
003371: 205631  
		   jms fget
003372: 102360  
		      jms error
003373: 101531  
		   lac f.flags
003374: 205757  
		   sma
003375: 740100  
		   jms error
003376: 101531  
		   lac f.i
003377: 205761  
		   jms iget
003400: 103017  
		   jmp finac i
003401: 623370  
			" update inode file size with value in AC
		dacisize: 0
003402: 000000  
		   dac i.size
003403: 045744  
		   jms iput
003404: 103046  
		   lac i.size
003405: 205744  
		   jmp dacisize i
003406: 623402  
		"** 01-s1.pdf page 41
		" s7
		pibreak:			" priority interrupt break processing "chain"
		   dac .ac			" save interrupt AC
003407: 044071  
			"** CROSSED OUT....
		   dpsf
003410: 704741  
		   jmp 1f		" disable the Graphics-2 I/O
003411: 603432  
		   dpcf
003412: 704761  
		   dprs
003413: 704752  
		   dac dpstat
003414: 045532  
		   sma ral
003415: 740110  
		   jmp 2f
003416: 603425  
		   dprc
003417: 704712  
		   dac dpchar
003420: 045535  
		   -1
003421: 777777  
		   dac dpread
003422: 045533  
		   lac dpstat
003423: 205532  
		   ral
003424: 740010  
		2:
		   sma
003425: 740100  
		   jmp piret
003426: 603755  
		   -1
003427: 777777  
		   dac dpwrite
003430: 045534  
		   jmp piret	"** END OF CROSSOUT
003431: 603755  
		1: clsf			" clock overflow (line frequency ticks)?
003432: 700001  
		   jmp 1f		"  no
003433: 603466  
		   lpb			" load display push buttons
003434: 704412  
		   dac pbsflgs		" save
003435: 045476  
		   isz s.tim+1		" increment low order tick count
003436: 445560  
		   skp			"  no overflow, skip second increment
003437: 741000  
		   isz s.tim		"   low order overflowed, increment high order count
003440: 445557  
		   isz uquant		"    increment user quantum counter
003441: 445474  
			"** written: ttydelay -> ttyd1
			"** written: ttyrestart -> ttyres1
		cnop:			" fetched as constant in iread
		   nop			
003442: 740000  
		   -1
003443: 777777  
		   dac 7		" set location 7 to -1 (nothing ever clears it)
003444: 040007  
		   clon			" enable clock interrupts, reset flag
003445: 700044  
		   lac ttydelay		" tty delay positive?
003446: 205503  
		   spa			"  yes: skip to skp
003447: 741100  
		   isz ttydelay		"   no: done delaying?
003450: 445503  
		   skp			"    not done
003451: 741000  
		   jms ttyrestart	"     yes: start output
003452: 103572  
			"** START CROSSED OUT: written: lac tty
		   lac .dspb
003453: 205536  
		   sna
003454: 741200  
		   jmp piret
003455: 603755  
		   isz .dsptm
003456: 444073  
		   skp
003457: 741000  
		   jmp dsprestart
003460: 603512  
		   sad d3
003461: 544121  
		   jmp piret
003462: 603755  
		   isz .dspb
003463: 445536  
		   jmp piret
003464: 603755  
		   jmp dsprestart "** END CROSSED OUT
003465: 603512  
		1: dssf				" disk flag set?
003466: 707121  
		   jmp 1f			"  no
003467: 603476  
		   -1				" set .dskb = -1
003470: 777777  
		   dac .dskb
003471: 044074  
		"** 01-s1.pdf page 42
		   dsrs				" get disk status in .dske
003472: 707132  
		   dac .dske
003473: 044075  
		   dscs				" clear status register
003474: 707141  
		   jmp piret
003475: 603755  
				"** BEGIN CROSSED OUT
		1: lds				" load display status (see 03-scope.pdf pg 25)
003476: 701052  
		   sma ral			" display trap set? (and rotate left)
003477: 740110  
		   jmp 1f			"  not set
003500: 603521  
		   cdf				" display done executing; clear display flags
003501: 700501  
		   lac .dspb
003502: 205536  
		   sna
003503: 741200  
		   jmp piret			" return now if .dspb == 0
003504: 603755  
		   tad dm3
003505: 344203  
		   sna
003506: 741200  
		   jmp dsprestart		" start display if .dspb == 3
003507: 603512  
		   dac .dspb			" otherwise, .dspb -= 3 and return
003510: 045536  
		   jmp piret
003511: 603755  
		dsprestart:
		   lac d1
003512: 204117  
		   dac .dspb			" set .dspb = 1
003513: 045536  
		   lac dspbufp			" load display buf pointer
003514: 205475  
		   beg				" start display processor
003515: 700547  
		   -10
003516: 777766  
		   dac .dsptm			" set .dsptm = -10 (10 ticks)
003517: 044073  
		   jmp piret
003520: 603755  
		1: sma ral			" edges flag set?? (and rotate)
003521: 740110  
		   jmp .+3			"  no
003522: 603525  
		   raef				" "resume after edges flag"
003523: 700742  
		   jmp piret			" return
003524: 603755  
		   sma				" light pen flag?
003525: 740100  
		   jmp 1f			"  no
003526: 603533  
		   lda				" G-2: load display address
003527: 701012  
		   dac .lpba			" save
003530: 045537  
		   rlpd				" G-2: resume after light pen stop
003531: 700723  
		   jmp piret
003532: 603755  
		1: ksf				" (TTY) keyboard flag set?
003533: 700301  
		   jmp 1f			"  no
003534: 603565  
		   lac ttydelay			" get TTY delay
003535: 205503  
		   sma				" minus (waiting for output)?
003536: 740100  
		   isz ttydelay			"  no: increment??? (make more positive)
003537: 445503  
		   krb				" read keyboard buffer
003540: 700312  
		   dac char			" save in char
003541: 045511  
		   sad o375			" interrupt char (TTY ALT MODE?)
003542: 544151  
		   jmp intrp1			"  yes
003543: 604021  
		   lac d1
003544: 204117  
		   jms putchar
003545: 101730  
		      dzm char
003546: 145511  
		   lac sfiles+0			" get sleep word for ttyin
003547: 205520  
		   jms wakeup			" wake processes
003550: 103762  
		   dac sfiles+0			" clear sleep word
003551: 045520  
		   lac char			" get character
003552: 205511  
		   sad o212			" new line (with parity)??
003553: 544150  
		   skp				"  yes
003554: 741000  
		   jmp piret			"   no: done
003555: 603755  
		   lac sfiles+1			" get ttyout sleep word
003556: 205521  
		   sma				" highest bit set?
003557: 740100  
		   xor o400000			" no, make it so (why?]
003560: 244173  
		   dac sfiles+1			" save back
003561: 045521  
		"** 01-s1.pdf page 43
		   jms putcr			" output CR next
003562: 104014  
		   jms ttyrestart		" start output
003563: 103572  
		   jmp piret
003564: 603755  
		1: tsf				" TTY output flag set?
003565: 700401  
		   jmp 1f			"  no
003566: 603626  
		   tcf				" yes: clear flag
003567: 700402  
		   jms ttyrestart		" transmit next character
003570: 103572  
		   jmp piret
003571: 603755  
		ttyrestart: 0
003572: 000000  
		   lac ttydelay			" get tty delay
003573: 205503  
		   spa				" positive?
003574: 741100  
		   jmp ttyrestart i		"  no: keep waiting
003575: 623572  
		   lac nttychar			" get pending CR, if any
003576: 205501  
		   dzm nttychar			" clear it
003577: 145501  
		   sza				" need to send CR?
003600: 740200  
		   jmp 3f			"  yes
003601: 603606  
		   isz ttydelay			" increment ttydelay (make more positive)
003602: 445503  
		   lac d2
003603: 204120  
		   jms getchar			" get a character
003604: 101745  
		      jmp 2f			"  none found??
003605: 603622  
		3:
		   tls				" start output
003606: 700406  
		   sad o12			" newline?
003607: 544130  
		   jms putcr			" yes: put CR next
003610: 104014  
		   sad o15			" CR?
003611: 544132  
		   skp				"  yes
003612: 741000  
		   jmp ttyrestart i		"   no: return
003613: 623572  
		   lac ttydelay			" get current tty delay
003614: 205503  
		   tad o20			" bump by 16
003615: 344134  
		   rcr				" divide by two
003616: 744020  
		   cma				" complement
003617: 740001  
		   dac ttydelay			" save
003620: 045503  
		   jmp ttyrestart i
003621: 623572  
		2:
		   lac sfiles+1			" run out of characters to send: wake user(s)
003622: 205521  
		   jms wakeup
003623: 103762  
		   dac sfiles+1
003624: 045521  
		   jmp ttyrestart i	"** written arrow up 2 copies
003625: 623572  
					"** BEGIN CROSSED OUT
		1: sck				" Graphic-2 keyboard flag set?
003626: 704301  
		   jmp 1f			"  no.
003627: 603644  
		   cck				" yes: clear flag
003630: 704304  
		   lck				" read character
003631: 704312  
		   dac char
003632: 045511  
		   sad o33			" code 33 (ESCAPE?)
003633: 544135  
		   jmp intrp2			"  yes: mark interrupt
003634: 604044  
		   lac d3
003635: 204121  
		   jms putchar
003636: 101730  
		      nop
003637: 740000  
		   lac sfiles+2
003640: 205522  
		   jms wakeup
003641: 103762  
		   dac sfiles+2
003642: 045522  
		   jmp piret
003643: 603755  
		1: rsf				" paper tape ready?
003644: 700101  
		   jmp 1f			"  no
003645: 603712  
		"** 01-s1.pdf page 44
		   lac npptchar
003646: 205502  
		   sna
003647: 741200  
		   jmp .+5
003650: 603655  
		   dac char
003651: 045511  
		   rrb
003652: 700112  
		   dac npptchar
003653: 045502  
		   jmp .+3
003654: 603657  
		   rrb
003655: 700112  
		   dac char
003656: 045511  
		3:
		   lac char
003657: 205511  
		   sna
003660: 741200  
		   jmp 2f
003661: 603670  
		   lac d4
003662: 204122  
		   jms putchar
003663: 101730  
		      jmp 3f
003664: 603704  
		   lac char
003665: 205511  
		   sad d4
003666: 544122  
		   jmp 4f
003667: 603706  
		2:
		   lac npptchar
003670: 205502  
		   sna
003671: 741200  
		   jmp .+4
003672: 603676  
		   dac char
003673: 045511  
		   dzm npptchar
003674: 145502  
		   jmp 3b
003675: 603657  
		   rsa
003676: 700104  
		   lac sfiles+3
003677: 205523  
		   jms wakeup
003700: 103762  
		   xor o400000
003701: 244173  
		   dac sfiles+3
003702: 045523  
		   jmp piret
003703: 603755  
		3:
		   lac char
003704: 205511  
		   dac npptchar
003705: 045502  
		4:
		   lac sfiles+3
003706: 205523  
		   jms wakeup
003707: 103762  
		   dac sfiles+3
003710: 045523  
		   jmp piret
003711: 603755  
		1: psf					" paper tape ready?
003712: 700201  
		   jmp 1f				"  no
003713: 603726  
		   pcf					" clear ptp flag
003714: 700202  
		   lac d5
003715: 204123  
		   jms getchar				" get next char
003716: 101745  
		   jmp .+3
003717: 603722  
		   psa
003720: 700204  
		   jmp piret
003721: 603755  
		   lac sfiles+4
003722: 205524  
		   jms wakeup
003723: 103762  
		   dac sfiles+4
003724: 045524  
		   jmp piret
003725: 603755  
				"** BEGIN CROSSED OUT
		1: spb					" any graphic-2 push button?
003726: 704401  
		   jmp 1f				"  no
003727: 603745  
		   cpb					" clear push button flag
003730: 704404  
		   lpb					" load push button value
003731: 704412  
		   dac pbsflgs+1
003732: 045477  
		"** 01-s1.pdf page 45
		   and o2000				" get push button 7
003733: 504153  
		   sna					" set?
003734: 741200  
		   jmp piret				"  no: done
003735: 603755  
		   jms dspinit				" yes: reset display buffer
003736: 102606  
		   lac sfiles+6				" wake up anyone sleeping on display
003737: 205526  
		   jms wakeup
003740: 103762  
		   dac sfiles+6
003741: 045526  
		   cla					" clear button lights
003742: 750000  
		   wbl
003743: 704424  
		   jmp piret	"** END CROSSED OUT
003744: 603755  
		1: crsf					" card reader flag set?
003745: 706701  
		   jmp 1f				"  no
003746: 603754  
		   crrb
003747: 706712  
		   dac crchar
003750: 045541  
		   -1
003751: 777777  
		   dac crread
003752: 045540  
		   jmp piret
003753: 603755  
		1: crrb					" read card reader buffer??
003754: 706712  
		piret:					" return from priority interrupt
		   lac 0				" get LINK/PC
003755: 200000  
		   ral					" restore LINK
003756: 740010  
		   lac .ac				" restore AC
003757: 204071  
		   ion					" reenable interrupts
003760: 700042  
		   jmp 0 i				" return from interrupt
003761: 620000  
			" wake sleeping processes
			" NOTE!! Called from interrupt service, so avoids indirect!!!
			" call:
			" AC/ sfiles word (bit vector of processes to wake)
			"   jms wakeup
			" AC/ 0 (to store in sfiles word)
		wakeup: 0
003762: 000000  
		   dac 9f+t				" save vector in t0
003763: 044255  
		   -mnproc
003764: 777766  
		   dac 9f+t+1				" loop count in t1
003765: 044256  
		   lac tadu				" get "tad ulist"
003766: 204076  
		   dac 2f
003767: 044000  
		   lac dacu				" get "dac ulist"
003770: 204077  
		   dac 2f+1
003771: 044001  
		1:
		   lac 9f+t
003772: 204255  
		   ral					" rotate vector up one
003773: 740010  
		   dac 9f+t
003774: 044255  
		   sma					" high bit set?
003775: 740100  
		   jmp 2f+2				"  no: skip the fun
003776: 604002  
		   lac o700000				" yes: decrement process status (wake)
003777: 204200  
		2: tad ..				" (avoiding indirect)
004000: 340000  
		   dac ..
004001: 040000  
		   lac 2b				" advance tad operand by 4 words
004002: 204000  
		   tad d4
004003: 344122  
		   dac 2b
004004: 044000  
		   lac 2b+1				" advance tad operand by 4 words
004005: 204001  
		   tad d4
004006: 344122  
		   dac 2b+1
004007: 044001  
		   isz 9f+t+1				" done?
004010: 444256  
		   jmp 1b				"  no, keep going
004011: 603772  
		   cla					" return zero in AC
004012: 750000  
		   jmp wakeup i
004013: 623762  
		t = t+2
	000052  
			" call to output CR after LF (NL)
		putcr: 0
004014: 000000  
		   lac o15
004015: 204132  
		   dac nttychar
004016: 045501  
		"** 01-s1.pdf page 46
		   cla
004017: 750000  
		   jmp putcr i
004020: 624014  
		intrp1:				" here with TTY interrupt character
		   lac d6			" get keyboard special device number
004021: 204124  
		   dac .int1			" save as interrupt source
004022: 044067  
		   lac d1			" drain tty input buffer?
004023: 204117  
		   jms getchar
004024: 101745  
		      skp
004025: 741000  
		   jmp .-3
004026: 604023  
		   lac d2			" drain tty output buffer?
004027: 204120  
		   jms getchar
004030: 101745  
		      skp
004031: 741000  
		   jmp .-3
004032: 604027  
		   lac sfiles+0			" wake ttyin sleepers
004033: 205520  
		   jms wakeup
004034: 103762  
		   dac sfiles+0
004035: 045520  
		   lac sfiles+1			" wake ttyout sleepers
004036: 205521  
		   jms wakeup
004037: 103762  
		   dac sfiles+1
004040: 045521  
		   jms chkint			" check if user interrupted
004041: 100320  
		      jmp piret			"  no, return from PI
004042: 603755  
		   jmp 1f			" yes: return thru system call code (dump core)
004043: 604062  
		intrp2:				" here with display interrupt character
		   lac d7			" get keyboard special device number
004044: 204125  
		   dac .int2			" save as interrupt source
004045: 044070  
		   lac d3			" drain keyboard buffer?
004046: 204121  
		   jms getchar
004047: 101745  
		      skp
004050: 741000  
		   jmp .-3
004051: 604046  
		   lac sfiles+2			" wake up any "keyboard" sleepers
004052: 205522  
		   jms wakeup
004053: 103762  
		   dac sfiles+2
004054: 045522  
		   lac sfiles+6			" wake up any "display" sleepers
004055: 205526  
		   jms wakeup
004056: 103762  
		   dac sfiles+6
004057: 045526  
		   jms chkint			" check if user interrupted
004060: 100320  
		      jmp piret			"  no, return from PI
004061: 603755  
		1:
		   lac 0			" get interrupt PC
004062: 200000  
		   dac 020			" save as system call return PC
004063: 040020  
		   lac .ac			" restore AC from interrupt
004064: 204071  
		   jmp 021			" join system call processing (dump core?)
004065: 600021  
		"** 01-s1.pdf page 48
		" s8
		" manifests
		mnproc = 10
	000012  
		dspbsz = 270
	000416  
		ndskbs = 4
	000004  
		" flags
		.insys: 0			" "in system"
004066: 000000  
		.int1: 0			" inode for user interrupt 1
004067: 000000  
		.int2: 0			" inode for user interrupt 2
004070: 000000  
		.ac: 0				" saved AC from Priotity Interrupt
004071: 000000  
		.savblk: 0			" set by system call, cleared by disk i/o
004072: 000000  
		.dsptm: 0			" display restart countdown (10 ticks)
004073: 000000  
		.dskb: 0			" set on disk interrupt
004074: 000000  
		.dske: 0			" status from disk interrupt
004075: 000000  
		" pointers
		tadu: tad ulist
004076: 345561  
		dacu: dac ulist
004077: 045561  
		maxquant: 30
004100: 000036  
		ofilesp: u.ofiles
004101: 005654  
		idskpp: i.dskps
004102: 005733  
		dskbufp: dskbuf
004103: 007700  
		edspbuf: dspbuf+dspbsz
004104: 005064  
		dspbufp3: dspbuf+3
004105: 004451  
		fblksp: s.fblks
004106: 005544  
		dacq1: dac q1
004107: 044260  
		lacq1: lac q1
004110: 204260  
		q2p: q2
004111: 004300  
		" strings
		initf:
		   <i>n;<i>t;< > ;< > "
004112: 151156  
004113: 151164  
004114: 040040  
004115: 040040  
		" constants
		d0: 0
004116: 000000  
		d1: 1
004117: 000001  
		d2: 2
004120: 000002  
		d3: 3
004121: 000003  
		d4: 4
004122: 000004  
		d5: 5
004123: 000005  
		d6: 6
004124: 000006  
		d7: o7: 07
004125: 000007  
		d8: 8
004126: 000010  
		d9: 9
004127: 000011  
		o12: d10: 10
004130: 000012  
		o14: 014
004131: 000014  
		o15: 015
004132: 000015  
		o17: 017
004133: 000017  
		o20: 020
004134: 000020  
		o33: 033
004135: 000033  
		o40: 040
004136: 000040  
		o55: 055
004137: 000055  
		o77: 077
004140: 000077  
		d65:o101: 0101
004141: 000101  
		d33: 33
004142: 000041  
		o132: 0132
004143: 000132  
		o134: 0134
004144: 000134  
		o137: 0137
004145: 000137  
		o155: 0155
004146: 000155  
		o177: 0177
004147: 000177  
		"** 01-s1.pdf page 49
		o212: 0212
004150: 000212  
		o375: 0375
004151: 000375  
		o777: 0777
004152: 000777  
		o2000: 02000
004153: 002000  
		o4000: 04000
004154: 004000  
		d7999: 7999
004155: 017477  
		o10000: 010000
004156: 010000  
		o17762: 017762
004157: 017762  
		o17777: 017777
004160: 017777  
		o20001: 020001
004161: 020001  
		o40000: 040000
004162: 040000  
		o40001: 040001
004163: 040001  
		o70000: 070000
004164: 070000  
		o77777: 077777
004165: 077777  
		o100000: 0100000
004166: 100000  
		o140000: 0140000
004167: 140000  
		o200000: 0200000
004170: 200000  
		o200001: 0200001
004171: 200001  
		o300000: 0300000
004172: 300000  
		o400000: 0400000
004173: 400000  
		o500000: 0500000
004174: 500000  
		o577777: 0577777
004175: 577777  
		o600000: 0600000
004176: 600000  
		o640000: 0640000
004177: 640000  
		o700000: 0700000
004200: 700000  
		o777700: 0777700
004201: 777700  
		o777760: 0777760
004202: 777760  
		dm3: -3
004203: 777775  
		dm1: -1
004204: 777777  
		9: .=.+t			" per-routine temp variables
	1004257  
		c1: .=.+1			" not used?
	1004260  
		q1: q2;q2+98	" ** 90?  96??	" queue element free list?
004260: 004300  
004261: 004442  
		   .=.+14
	1004300  
			" queues (two words each, head and tail pointers?)
			"  1: tty input
			"  2: tty output
			"  3: display keyboard
			"  4: paper tape reader
			"  5: paper tape punch
		q2:
		   .+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0
004300: 004302  
004301: 000000  
004302: 004304  
004303: 000000  
004304: 004306  
004305: 000000  
004306: 004310  
004307: 000000  
004310: 004312  
004311: 000000  
004312: 004314  
004313: 000000  
004314: 004316  
004315: 000000  
004316: 004320  
004317: 000000  
004320: 004322  
004321: 000000  
004322: 004324  
004323: 000000  
		   .+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0
004324: 004326  
004325: 000000  
004326: 004330  
004327: 000000  
004330: 004332  
004331: 000000  
004332: 004334  
004333: 000000  
004334: 004336  
004335: 000000  
004336: 004340  
004337: 000000  
004340: 004342  
004341: 000000  
004342: 004344  
004343: 000000  
004344: 004346  
004345: 000000  
004346: 004350  
004347: 000000  
		   .+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0
004350: 004352  
004351: 000000  
004352: 004354  
004353: 000000  
004354: 004356  
004355: 000000  
004356: 004360  
004357: 000000  
004360: 004362  
004361: 000000  
004362: 004364  
004363: 000000  
004364: 004366  
004365: 000000  
004366: 004370  
004367: 000000  
004370: 004372  
004371: 000000  
004372: 004374  
004373: 000000  
		   .+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0
004374: 004376  
004375: 000000  
004376: 004400  
004377: 000000  
004400: 004402  
004401: 000000  
004402: 004404  
004403: 000000  
004404: 004406  
004405: 000000  
004406: 004410  
004407: 000000  
004410: 004412  
004411: 000000  
004412: 004414  
004413: 000000  
004414: 004416  
004415: 000000  
004416: 004420  
004417: 000000  
		   .+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;.+2;0;0;0
004420: 004422  
004421: 000000  
004422: 004424  
004423: 000000  
004424: 004426  
004425: 000000  
004426: 004430  
004427: 000000  
004430: 004432  
004431: 000000  
004432: 004434  
004433: 000000  
004434: 004436  
004435: 000000  
004436: 004440  
004437: 000000  
004440: 004442  
004441: 000000  
004442: 000000  
004443: 000000  
		dsploc: .=.+1
	1004445  
		dsplno: .=.+1
	1004446  
		dspbuf:
		   0065057;0147740;0160000	" display commands: see 03-scope.pdf pg 20
004446: 065057  
004447: 147740  
004450: 160000  
			" PARAM: clear blink, clear light pen, scale=1, intensity=3
			" X-Y: invisible, no delay, Y=01740 (992)
			" X-Y: invisible, settling delay, X=0
		   .=.+30
	1004507  
		coldentry:
		   dzm 0100 " not re-entrant
004507: 140100  
		   caf				" clear all flags
004510: 703302  
		   ion				" enable interrupts
004511: 700042  
		   clon				" clear clock flag
004512: 700044  
		   law 3072			" initialize display....
004513: 766000  
		   wcga
004514: 704206  
		   jms dspinit
004515: 102606  
		   law dspbuf			" set display buffer to default
004516: 764446  
		   jms movdsp
004517: 102615  
		   cla				" read system block from disk
004520: 750000  
		   jms dskio; 06000
004521: 102162  
004522: 006000  
		   jms copy; dskbuf; sysdata; ulist-sysdata	" copy to system data
004523: 101667  
004524: 007700  
004525: 005542  
004526: 000017  
		   lac d3			" look for "init" in default directory
004527: 204121  
		   jms namei; initf
004530: 102737  
004531: 004112  
		      jms halt
004532: 102254  
		"** 01-s1.pdf page 50
		   jms iget
004533: 103017  
		   cla
004534: 750000  
		   jms iread; 4096; 4096	" read in "init"
004535: 103266  
004536: 010000  
004537: 010000  
		   jmp 4096			" start process 1
004540: 610000  
		   . = dspbuf+dspbsz+3
	1005067  
		dskbuf = 07700
	007700  
		dskbs: .=.+65+65+65+65
	1005473  
		edskbsp: .
005473: 005473  
		uquant: .=.+1			" number of ticks user has been running
	1005475  
		dspbufp: .=.+1			" pointer to display buffer
	1005476  
		pbsflgs: .=.+2			" buttons on last tick, last button interrupt
	1005500  
		mode: .=.+1
	1005501  
		nttychar: .=.+1			" CR to send next, or zero
	1005502  
		npptchar: .=.+1
	1005503  
		ttydelay: .=.+1			" delay count for TTY output
	1005504  
		name: .=.+4
	1005510  
		lnkaddr: .=.+1
	1005511  
		char: .=.+1
	1005512  
		dskaddr: .=.+1
	1005513  
		uniqpid: 1			" pid generator
005513: 000001  
		lu: .=.+4			" user (process) table entry copy
	1005520  
		sfiles: .=.+10			" wait addresses for special files
	1005532  
				" (bit vector of waiting processes?)
				" offsets:	0: ttyin, 1: ttyout, 2: keyboard,
				"		3: ptr,   4: ptp,    6: display
		dpdata:
		   dpstat: .=.+1
	1005533  
		   dpread: .=.+1
	1005534  
		   dpwrite: .=.+1
	1005535  
		   dpchar: .=.+1
	1005536  
		dspdata:
		   .dspb: .=.+1
	1005537  
		   .lpba: .=.+1	"** 4 written on listing
	1005540  
		crdata:
		   crread: .=.+1
	1005541  
		   crchar: .=.+1
	1005542  
		sysdata:			" system data 64 words saved to disk
		   s.nxfblk: .=.+1		" pointer to next free block??
	1005543  
		   s.nfblks: .=.+1		" number of free blocks (in fblks?)
	1005544  
		   s.fblks: .=.+10		" cached free block numbers
	1005556  
		   s.uniq: .=.+1		" next unique value
	1005557  
		   s.tim: .=.+2			" (up?)time in 60Hz ticks (low, high)
	1005561  
			" process table
			" first word
			"   bits 0:2 -- status
			"	0: free slot
			"	1: in/ready
			"	2: in/notready
			"	3: out/ready
			"	4: out/notready??
			"   bits 3:17 -- disk swap address/8
			" second word: process pid
			" third word:  smes/rmes status:
			"	0: not waiting
			"	-1: this process waiting (rmes)
			"	other: complement of sender pid
			" fourth word: smes message
		ulist:
		   0131000;1;0;0
005561: 131000  
005562: 000001  
005563: 000000  
005564: 000000  
		   0031040;0;0;0
005565: 031040  
005566: 000000  
005567: 000000  
005570: 000000  
		   0031100;0;0;0
005571: 031100  
005572: 000000  
005573: 000000  
005574: 000000  
		   0031140;0;0;0
005575: 031140  
005576: 000000  
005577: 000000  
005600: 000000  
		   0031200;0;0;0
005601: 031200  
005602: 000000  
005603: 000000  
005604: 000000  
		   0031240;0;0;0
005605: 031240  
005606: 000000  
005607: 000000  
005610: 000000  
		   0031300;0;0;0
005611: 031300  
005612: 000000  
005613: 000000  
005614: 000000  
		   0031340;0;0;0
005615: 031340  
005616: 000000  
005617: 000000  
005620: 000000  
		   0031400;0;0;0
005621: 031400  
005622: 000000  
005623: 000000  
005624: 000000  
		   0031440;0;0;0
005625: 031440  
005626: 000000  
005627: 000000  
005630: 000000  
		userdata:			" "ustruct" (swappable)
		   u.ac: 0			" user AC
005631: 000000  
		   u.mq: 0			" user MQ
005632: 000000  
		   u.rq: .=.+9			" user 010-017, user PC
	1005644  
		   u.uid: -1			" user id
005644: 777777  
		   u.pid: 1			" process id
005645: 000001  
		   u.cdir: 3			" connected directory (inode number?)
005646: 000003  
		   u.ulistp: ulist		" pointer to process table entry
005647: 005561  
		   u.swapret: 0			" kernel routine to resume at after swap in
005650: 000000  
		   u.base: 0			" start of user buffer
005651: 000000  
		   u.count: 0			" size of user buffer
005652: 000000  
		"** 01-s1.pdf page 51
		   u.limit: 0			" end of user buffer
005653: 000000  
		   u.ofiles: .=.+30		" open files (10 "fnode" entries)
	1005712  
		   u.dspbuf: 0
005712: 000000  
		   u.intflg: 1
005713: 000001  
		      .=userdata+64
	1005731  
		ii: .=.+1			" The current i-node number stored in inode
	1005732  
		inode:				" disk inode in memory:
		   i.flags: .=.+1		" inode flags
	1005733  
						" 400000 in use
						" 200000 large file
						" 000040 special device (indicated by inum)
						" 000020 directory
						" 000010 owner read
						" 000004 owner write
						" 000002 world read
						" 000001 world write
		   i.dskps: .=.+7		" disk block numbers (indirect if "large file")
	1005742  
		   i.uid: .=.+1			" owner
	1005743  
		   i.nlks: .=.+1		" link count (negative)
	1005744  
		   i.size: .=.+1		" size (in words)
	1005745  
		   i.uniq: .=.+1		" unique number
	1005746  
		      .= inode+12
	1005746  
		di: .=.+1			" directory index
	1005747  
		dnode:				" directory entry:
		   d.i: .=.+1			" inode number
	1005750  
		   d.name: .=.+4		" name (space padded)
	1005754  
		   d.uniq: .=.+1		" unique number from directory inode
	1005755  
		      . = dnode+8
	1005757  
		fnode:				" open file entry
		   f.flags: .=.+1		" see below
	1005760  
		   f.badd: .=.+1		" offset
	1005761  
		   f.i: 0			" file i-number
005761: 000000  
		"	f.flags:
		"		400000	in use
		"		000002	read
		"		000001	write

Labels:
.ac      004071 r
.capt    000377 r
.chdir   000615 r
.chmod   000407 r
.chown   000421 r
.close   000720 r
.creat   000660 r
.dskb    004074 r
.dske    004075 r
.dspb    005536 r
.dsptm   004073 r
.exit    001163 r
.fork    001111 r
.getuid  000426 r
.halt    001336 r
.insys   004066 r
.int1    004067 r
.int2    004070 r
.intrp   000257 r
.link    000467 r
.lpba    005537 r
.open    000626 r
.read    000724 r
.rele    000403 r
.rename  000567 r
.rmes    001177 r
.savblk  004072 r
.save    001151 r
.seek    000431 r
.setuid  000561 r
.smes    001225 r
.status  000352 r
.sysloc  000262 r
.tell    000461 r
.time    000610 r
.unlink  000542 r
.write   000773 r
access   002312 r
alloc    001545 r
arg      002625 r
argname  002631 r
awake    001304 r
badcal   001146 r
betwen   001643 r
c1       004257 r
char     005511 r
chkint   000320 r
chkint1  001535 r
cnop     003442 r
coldentr 004507 r
collapse 002055 r
copy     001667 r
copyz    001712 r
crchar   005541 r
crdata   005540 r
crread   005540 r
cskp     003335 r
d.i      005747 r
d.name   005750 r
d.uniq   005754 r
d0       004116 r
d1       004117 r
d10      004130 r
d2       004120 r
d3       004121 r
d33      004142 r
d4       004122 r
d5       004123 r
d6       004124 r
d65      004141 r
d7       004125 r
d7999    004155 r
d8       004126 r
d9       004127 r
dacisize 003402 r
dacq1    004107 r
dacu     004077 r
dget     003104 r
di       005746 r
dm1      004204 r
dm3      004203 r
dnode    005747 r
dpchar   005535 r
dpdata   005532 r
dpread   005533 r
dpstat   005532 r
dput     003136 r
dpwrite  005534 r
dskaddr  005512 r
dskbs    005067 r
dskbufp  004103 r
dskio    002162 r
dskrd    002116 r
dskswap  002267 r
dsktrans 002220 r
dskwr    002146 r
dslot    002463 r
dspbuf   004446 r
dspbufp  005475 r
dspbufp3 004105 r
dspdata  005536 r
dspinit  002606 r
dspleft  002562 r
dsplno   004445 r
dsploc   004444 r
dspnl    002574 r
dspput   002540 r
dspresta 003512 r
edskbsp  005473 r
edspbuf  004104 r
error    001531 r
exitrw   001034 r
f.badd   005760 r
f.flags  005757 r
f.i      005761 r
fallr    002425 r
fassign  002327 r
fblksp   004106 r
fget     002360 r
finac    003370 r
fnode    005757 r
forall   002412 r
fput     002402 r
free     001604 r
getchar  001745 r
halt     002254 r
i.dskps  005733 r
i.flags  005732 r
i.nlks   005743 r
i.size   005744 r
i.uid    005742 r
i.uniq   005745 r
icreat   002475 r
idskpp   004102 r
iget     003017 r
ii       005731 r
initf    004112 r
inode    005732 r
intrp1   004021 r
intrp2   004044 r
iput     003046 r
iread    003266 r
isown    002664 r
itrunc   002675 r
iwrite   003257 r
laci     001635 r
lacq1    004110 r
lnkaddr  005510 r
locn     000317 r
locsw    000275 r
lookfor  001066 r
lu       005514 r
maxquant 004100 r
mode     005500 r
movdsp   002615 r
name     005504 r
namei    002737 r
npptchar 005502 r
nttychar 005501 r
o10000   004156 r
o100000  004166 r
o101     004141 r
o12      004130 r
o132     004143 r
o134     004144 r
o137     004145 r
o14      004131 r
o140000  004167 r
o15      004132 r
o155     004146 r
o17      004133 r
o177     004147 r
o17762   004157 r
o17777   004160 r
o20      004134 r
o2000    004153 r
o200000  004170 r
o200001  004171 r
o20001   004161 r
o212     004150 r
o300000  004172 r
o33      004135 r
o375     004151 r
o40      004136 r
o4000    004154 r
o40000   004162 r
o400000  004173 r
o40001   004163 r
o500000  004174 r
o55      004137 r
o577777  004175 r
o600000  004176 r
o640000  004177 r
o7       004125 r
o70000   004164 r
o700000  004200 r
o77      004140 r
o777     004152 r
o777700  004201 r
o777760  004202 r
o77777   004165 r
ofilesp  004101 r
okexit   000102 r
open1    000715 r
orig     000000 r
passone  001523 r
pbsflgs  005476 r
pget     003152 r
pibreak  003407 r
piret    003755 r
putchar  001730 r
putcr    004014 r
putq     002011 r
q1       004260 r
q2       004300 r
q2p      004111 r
rkbdi    001410 r
rppti    001461 r
rttyi    001337 r
s.fblks  005544 r
s.nfblks 005543 r
s.nxfblk 005542 r
s.tim    005557 r
s.uniq   005556 r
searchu  001042 r
seektell 002645 r
sfiles   005520 r
sleep    002434 r
srcdbs   002035 r
swap     000136 r
swn      000256 r
swp      000220 r
swr      001324 r
sww      001324 r
sysdata  005542 r
sysexit  000103 r
tadu     004076 r
takeq    001757 r
ttydelay 005503 r
ttyresta 003572 r
u.ac     005631 r
u.base   005651 r
u.cdir   005646 r
u.count  005652 r
u.dspbuf 005712 r
u.intflg 005713 r
u.limit  005653 r
u.mq     005632 r
u.ofiles 005654 r
u.pid    005645 r
u.rq     005633 r
u.swapre 005650 r
u.uid    005644 r
u.ulistp 005647 r
ulist    005561 r
uniqpid  005513 r
uquant   005474 r
userdata 005631 r
wakeup   003762 r
wdspo    001451 r
wppto    001475 r
wttyo    001357 r
